/**
 * 121-service [DEV]
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: v1.0.0-dev
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */
/* tslint:disable:no-unused-variable member-ordering */

import { Inject, Injectable, Optional }                      from '@angular/core';
import { HttpClient, HttpHeaders, HttpParams,
         HttpResponse, HttpEvent, HttpParameterCodec, HttpContext 
        }       from '@angular/common/http';
import { CustomHttpParameterCodec }                          from '../encoder';
import { Observable }                                        from 'rxjs';

// @ts-ignore
import { BulkActionResultDto } from '../model/bulk-action-result-dto';
// @ts-ignore
import { GetEventDto } from '../model/get-event-dto';
// @ts-ignore
import { ImportRegistrationsDto } from '../model/import-registrations-dto';
// @ts-ignore
import { RegistrationStatusPatchDto } from '../model/registration-status-patch-dto';
// @ts-ignore
import { RegistrationsControllerFindAll200Response } from '../model/registrations-controller-find-all200-response';
// @ts-ignore
import { SendCustomTextDto } from '../model/send-custom-text-dto';
// @ts-ignore
import { UpdateChosenFspDto } from '../model/update-chosen-fsp-dto';
// @ts-ignore
import { UpdateRegistrationDto } from '../model/update-registration-dto';

// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS }                     from '../variables';
import { Configuration }                                     from '../configuration';



@Injectable({
  providedIn: 'root'
})
export class ProgramsRegistrationsService {

    protected basePath = 'http://localhost:3000';
    public defaultHeaders = new HttpHeaders();
    public configuration = new Configuration();
    public encoder: HttpParameterCodec;

    constructor(protected httpClient: HttpClient, @Optional()@Inject(BASE_PATH) basePath: string|string[], @Optional() configuration: Configuration) {
        if (configuration) {
            this.configuration = configuration;
        }
        if (typeof this.configuration.basePath !== 'string') {
            const firstBasePath = Array.isArray(basePath) ? basePath[0] : undefined;
            if (firstBasePath != undefined) {
                basePath = firstBasePath;
            }

            if (typeof basePath !== 'string') {
                basePath = this.basePath;
            }
            this.configuration.basePath = basePath;
        }
        this.encoder = this.configuration.encoder || new CustomHttpParameterCodec();
    }

    /**
     * @param consumes string[] mime-types
     * @return true: consumes contains 'multipart/form-data', false: otherwise
     */
    private canConsumeForm(consumes: string[]): boolean {
        const form = 'multipart/form-data';
        for (const consume of consumes) {
            if (form === consume) {
                return true;
            }
        }
        return false;
    }

    // @ts-ignore
    private addToHttpParams(httpParams: HttpParams, value: any, key?: string): HttpParams {
        if (typeof value === "object" && value instanceof Date === false) {
            httpParams = this.addToHttpParamsRecursive(httpParams, value);
        } else {
            httpParams = this.addToHttpParamsRecursive(httpParams, value, key);
        }
        return httpParams;
    }

    private addToHttpParamsRecursive(httpParams: HttpParams, value?: any, key?: string): HttpParams {
        if (value == null) {
            return httpParams;
        }

        if (typeof value === "object") {
            if (Array.isArray(value)) {
                (value as any[]).forEach( elem => httpParams = this.addToHttpParamsRecursive(httpParams, elem, key));
            } else if (value instanceof Date) {
                if (key != null) {
                    httpParams = httpParams.append(key, (value as Date).toISOString().substring(0, 10));
                } else {
                   throw Error("key may not be null if value is Date");
                }
            } else {
                Object.keys(value).forEach( k => httpParams = this.addToHttpParamsRecursive(
                    httpParams, value[k], key != null ? `${key}.${k}` : k));
            }
        } else if (key != null) {
            httpParams = httpParams.append(key, value);
        } else {
            throw Error("key may not be null if value is not object or array");
        }
        return httpParams;
    }

    /**
     * Get list of events for a specific registrationId
     * @param registrationId 
     * @param programId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public eventsControllerGetEventsByRegistrationId(registrationId: number, programId: number, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<Array<GetEventDto>>;
    public eventsControllerGetEventsByRegistrationId(registrationId: number, programId: number, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<Array<GetEventDto>>>;
    public eventsControllerGetEventsByRegistrationId(registrationId: number, programId: number, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<Array<GetEventDto>>>;
    public eventsControllerGetEventsByRegistrationId(registrationId: number, programId: number, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {
        if (registrationId === null || registrationId === undefined) {
            throw new Error('Required parameter registrationId was null or undefined when calling eventsControllerGetEventsByRegistrationId.');
        }
        if (programId === null || programId === undefined) {
            throw new Error('Required parameter programId was null or undefined when calling eventsControllerGetEventsByRegistrationId.');
        }

        let localVarHeaders = this.defaultHeaders;

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }

        let localVarTransferCache: boolean | undefined = options && options.transferCache;
        if (localVarTransferCache === undefined) {
            localVarTransferCache = true;
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/api/programs/${this.configuration.encodeParam({name: "programId", value: programId, in: "path", style: "simple", explode: false, dataType: "number", dataFormat: undefined})}/registrations/${this.configuration.encodeParam({name: "registrationId", value: registrationId, in: "path", style: "simple", explode: false, dataType: "number", dataFormat: undefined})}/events`;
        return this.httpClient.request<Array<GetEventDto>>('get', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                transferCache: localVarTransferCache,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * [SCOPED] Delete set of registrations
     * @param programId 
     * @param page Not used for this endpoint
     * @param limit Not used for this endpoint
     * @param dryRun        Only when set explicitly to \&quot;true\&quot;, this will simulate (and NOT actually DO) the action.       Instead it will return how many PA this action can be applied to.       No registrations will be deleted.       
     * @param filterReferenceId Filter by referenceId query param.           &lt;p&gt;              &lt;b&gt;Format: &lt;/b&gt; filter.referenceId&#x3D;{$not}:OPERATION:VALUE           &lt;/p&gt;           &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; filter.referenceId&#x3D;$not:$like:John Doe&amp;filter.referenceId&#x3D;like:John           &lt;/p&gt;           &lt;h4&gt;Available Operations&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;$eq&lt;/li&gt; &lt;li&gt;$in&lt;/li&gt; &lt;li&gt;$ilike&lt;/li&gt; &lt;li&gt;$null&lt;/li&gt;&lt;/ul&gt;
     * @param filterStatus Filter by status query param.           &lt;p&gt;              &lt;b&gt;Format: &lt;/b&gt; filter.status&#x3D;{$not}:OPERATION:VALUE           &lt;/p&gt;           &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; filter.status&#x3D;$not:$like:John Doe&amp;filter.status&#x3D;like:John           &lt;/p&gt;           &lt;h4&gt;Available Operations&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;$eq&lt;/li&gt; &lt;li&gt;$in&lt;/li&gt; &lt;li&gt;$ilike&lt;/li&gt; &lt;li&gt;$null&lt;/li&gt;&lt;/ul&gt;
     * @param filterId Filter by id query param.           &lt;p&gt;              &lt;b&gt;Format: &lt;/b&gt; filter.id&#x3D;{$not}:OPERATION:VALUE           &lt;/p&gt;           &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; filter.id&#x3D;$not:$like:John Doe&amp;filter.id&#x3D;like:John           &lt;/p&gt;           &lt;h4&gt;Available Operations&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;$eq&lt;/li&gt; &lt;li&gt;$null&lt;/li&gt;&lt;/ul&gt;
     * @param filterRegistrationCreatedDate Filter by registrationCreatedDate query param.           &lt;p&gt;              &lt;b&gt;Format: &lt;/b&gt; filter.registrationCreatedDate&#x3D;{$not}:OPERATION:VALUE           &lt;/p&gt;           &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; filter.registrationCreatedDate&#x3D;$not:$like:John Doe&amp;filter.registrationCreatedDate&#x3D;like:John           &lt;/p&gt;           &lt;h4&gt;Available Operations&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;$eq&lt;/li&gt; &lt;li&gt;$in&lt;/li&gt; &lt;li&gt;$ilike&lt;/li&gt; &lt;li&gt;$null&lt;/li&gt;&lt;/ul&gt;
     * @param filterPhoneNumber Filter by phoneNumber query param.           &lt;p&gt;              &lt;b&gt;Format: &lt;/b&gt; filter.phoneNumber&#x3D;{$not}:OPERATION:VALUE           &lt;/p&gt;           &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; filter.phoneNumber&#x3D;$not:$like:John Doe&amp;filter.phoneNumber&#x3D;like:John           &lt;/p&gt;           &lt;h4&gt;Available Operations&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;$eq&lt;/li&gt; &lt;li&gt;$in&lt;/li&gt; &lt;li&gt;$ilike&lt;/li&gt; &lt;li&gt;$null&lt;/li&gt;&lt;/ul&gt;
     * @param filterPreferredLanguage Filter by preferredLanguage query param.           &lt;p&gt;              &lt;b&gt;Format: &lt;/b&gt; filter.preferredLanguage&#x3D;{$not}:OPERATION:VALUE           &lt;/p&gt;           &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; filter.preferredLanguage&#x3D;$not:$like:John Doe&amp;filter.preferredLanguage&#x3D;like:John           &lt;/p&gt;           &lt;h4&gt;Available Operations&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;$eq&lt;/li&gt; &lt;li&gt;$in&lt;/li&gt; &lt;li&gt;$ilike&lt;/li&gt; &lt;li&gt;$null&lt;/li&gt;&lt;/ul&gt;
     * @param filterInclusionScore Filter by inclusionScore query param.           &lt;p&gt;              &lt;b&gt;Format: &lt;/b&gt; filter.inclusionScore&#x3D;{$not}:OPERATION:VALUE           &lt;/p&gt;           &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; filter.inclusionScore&#x3D;$not:$like:John Doe&amp;filter.inclusionScore&#x3D;like:John           &lt;/p&gt;           &lt;h4&gt;Available Operations&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;$eq&lt;/li&gt; &lt;li&gt;$null&lt;/li&gt;&lt;/ul&gt;
     * @param filterPaymentAmountMultiplier Filter by paymentAmountMultiplier query param.           &lt;p&gt;              &lt;b&gt;Format: &lt;/b&gt; filter.paymentAmountMultiplier&#x3D;{$not}:OPERATION:VALUE           &lt;/p&gt;           &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; filter.paymentAmountMultiplier&#x3D;$not:$like:John Doe&amp;filter.paymentAmountMultiplier&#x3D;like:John           &lt;/p&gt;           &lt;h4&gt;Available Operations&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;$eq&lt;/li&gt; &lt;li&gt;$null&lt;/li&gt;&lt;/ul&gt;
     * @param filterFinancialServiceProvider Filter by financialServiceProvider query param.           &lt;p&gt;              &lt;b&gt;Format: &lt;/b&gt; filter.financialServiceProvider&#x3D;{$not}:OPERATION:VALUE           &lt;/p&gt;           &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; filter.financialServiceProvider&#x3D;$not:$like:John Doe&amp;filter.financialServiceProvider&#x3D;like:John           &lt;/p&gt;           &lt;h4&gt;Available Operations&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;$eq&lt;/li&gt; &lt;li&gt;$in&lt;/li&gt; &lt;li&gt;$ilike&lt;/li&gt; &lt;li&gt;$null&lt;/li&gt;&lt;/ul&gt;
     * @param filterFspDisplayName Filter by fspDisplayName query param.           &lt;p&gt;              &lt;b&gt;Format: &lt;/b&gt; filter.fspDisplayName&#x3D;{$not}:OPERATION:VALUE           &lt;/p&gt;           &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; filter.fspDisplayName&#x3D;$not:$like:John Doe&amp;filter.fspDisplayName&#x3D;like:John           &lt;/p&gt;           &lt;h4&gt;Available Operations&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;$eq&lt;/li&gt; &lt;li&gt;$in&lt;/li&gt; &lt;li&gt;$ilike&lt;/li&gt; &lt;li&gt;$null&lt;/li&gt;&lt;/ul&gt;
     * @param filterRegistrationProgramId Filter by registrationProgramId query param.           &lt;p&gt;              &lt;b&gt;Format: &lt;/b&gt; filter.registrationProgramId&#x3D;{$not}:OPERATION:VALUE           &lt;/p&gt;           &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; filter.registrationProgramId&#x3D;$not:$like:John Doe&amp;filter.registrationProgramId&#x3D;like:John           &lt;/p&gt;           &lt;h4&gt;Available Operations&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;$eq&lt;/li&gt; &lt;li&gt;$null&lt;/li&gt;&lt;/ul&gt;
     * @param filterMaxPayments Filter by maxPayments query param.           &lt;p&gt;              &lt;b&gt;Format: &lt;/b&gt; filter.maxPayments&#x3D;{$not}:OPERATION:VALUE           &lt;/p&gt;           &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; filter.maxPayments&#x3D;$not:$like:John Doe&amp;filter.maxPayments&#x3D;like:John           &lt;/p&gt;           &lt;h4&gt;Available Operations&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;$eq&lt;/li&gt; &lt;li&gt;$null&lt;/li&gt;&lt;/ul&gt;
     * @param filterPaymentCount Filter by paymentCount query param.           &lt;p&gt;              &lt;b&gt;Format: &lt;/b&gt; filter.paymentCount&#x3D;{$not}:OPERATION:VALUE           &lt;/p&gt;           &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; filter.paymentCount&#x3D;$not:$like:John Doe&amp;filter.paymentCount&#x3D;like:John           &lt;/p&gt;           &lt;h4&gt;Available Operations&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;$eq&lt;/li&gt; &lt;li&gt;$null&lt;/li&gt;&lt;/ul&gt;
     * @param filterPaymentCountRemaining Filter by paymentCountRemaining query param.           &lt;p&gt;              &lt;b&gt;Format: &lt;/b&gt; filter.paymentCountRemaining&#x3D;{$not}:OPERATION:VALUE           &lt;/p&gt;           &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; filter.paymentCountRemaining&#x3D;$not:$like:John Doe&amp;filter.paymentCountRemaining&#x3D;like:John           &lt;/p&gt;           &lt;h4&gt;Available Operations&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;$eq&lt;/li&gt; &lt;li&gt;$null&lt;/li&gt;&lt;/ul&gt;
     * @param filterPersonAffectedSequence Filter by personAffectedSequence query param.           &lt;p&gt;              &lt;b&gt;Format: &lt;/b&gt; filter.personAffectedSequence&#x3D;{$not}:OPERATION:VALUE           &lt;/p&gt;           &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; filter.personAffectedSequence&#x3D;$not:$like:John Doe&amp;filter.personAffectedSequence&#x3D;like:John           &lt;/p&gt;           &lt;h4&gt;Available Operations&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;$eq&lt;/li&gt; &lt;li&gt;$in&lt;/li&gt; &lt;li&gt;$ilike&lt;/li&gt; &lt;li&gt;$null&lt;/li&gt;&lt;/ul&gt;
     * @param filterLastMessageStatus Filter by lastMessageStatus query param.           &lt;p&gt;              &lt;b&gt;Format: &lt;/b&gt; filter.lastMessageStatus&#x3D;{$not}:OPERATION:VALUE           &lt;/p&gt;           &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; filter.lastMessageStatus&#x3D;$not:$like:John Doe&amp;filter.lastMessageStatus&#x3D;like:John           &lt;/p&gt;           &lt;h4&gt;Available Operations&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;$eq&lt;/li&gt; &lt;li&gt;$in&lt;/li&gt; &lt;li&gt;$ilike&lt;/li&gt; &lt;li&gt;$null&lt;/li&gt;&lt;/ul&gt;
     * @param filterFailedPayment Filter by failedPayment query param.           &lt;p&gt;              &lt;b&gt;Format: &lt;/b&gt; filter.failedPayment&#x3D;{$not}:OPERATION:VALUE           &lt;/p&gt;           &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; filter.failedPayment&#x3D;$not:$like:John Doe&amp;filter.failedPayment&#x3D;like:John           &lt;/p&gt;           &lt;h4&gt;Available Operations&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;$eq&lt;/li&gt; &lt;li&gt;$null&lt;/li&gt;&lt;/ul&gt;
     * @param filterWaitingPayment Filter by waitingPayment query param.           &lt;p&gt;              &lt;b&gt;Format: &lt;/b&gt; filter.waitingPayment&#x3D;{$not}:OPERATION:VALUE           &lt;/p&gt;           &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; filter.waitingPayment&#x3D;$not:$like:John Doe&amp;filter.waitingPayment&#x3D;like:John           &lt;/p&gt;           &lt;h4&gt;Available Operations&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;$eq&lt;/li&gt; &lt;li&gt;$null&lt;/li&gt;&lt;/ul&gt;
     * @param filterSuccessPayment Filter by successPayment query param.           &lt;p&gt;              &lt;b&gt;Format: &lt;/b&gt; filter.successPayment&#x3D;{$not}:OPERATION:VALUE           &lt;/p&gt;           &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; filter.successPayment&#x3D;$not:$like:John Doe&amp;filter.successPayment&#x3D;like:John           &lt;/p&gt;           &lt;h4&gt;Available Operations&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;$eq&lt;/li&gt; &lt;li&gt;$null&lt;/li&gt;&lt;/ul&gt;
     * @param filterNotYetSentPayment Filter by notYetSentPayment query param.           &lt;p&gt;              &lt;b&gt;Format: &lt;/b&gt; filter.notYetSentPayment&#x3D;{$not}:OPERATION:VALUE           &lt;/p&gt;           &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; filter.notYetSentPayment&#x3D;$not:$like:John Doe&amp;filter.notYetSentPayment&#x3D;like:John           &lt;/p&gt;           &lt;h4&gt;Available Operations&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;$eq&lt;/li&gt; &lt;li&gt;$null&lt;/li&gt;&lt;/ul&gt;
     * @param sortBy Parameter to sort by.       &lt;p&gt;To sort by multiple fields, just provide query param multiple types. The order in url defines an order of sorting&lt;/p&gt;       &lt;p&gt;              &lt;b&gt;Format: &lt;/b&gt; fieldName:DIRECTION           &lt;/p&gt;       &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; sortBy&#x3D;id:DESC&amp;sortBy&#x3D;createdAt:ASC           &lt;/p&gt;       &lt;p&gt;              &lt;b&gt;Default Value: &lt;/b&gt; No default sorting specified, the result order is not guaranteed           &lt;/p&gt;       &lt;h4&gt;Available Fields&lt;/h4&gt;&lt;ul&gt;&lt;/ul&gt;       
     * @param search Search term to filter result values         &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; John           &lt;/p&gt;         &lt;p&gt;              &lt;b&gt;Default Value: &lt;/b&gt; No default value           &lt;/p&gt;         
     * @param searchBy List of fields to search by term to filter result values         &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; data.(value)           &lt;/p&gt;         &lt;p&gt;              &lt;b&gt;Default Value: &lt;/b&gt; By default all fields mentioned below will be used to search by term           &lt;/p&gt;         &lt;h4&gt;Available Fields&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;data.(value)&lt;/li&gt;&lt;/ul&gt;         
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public registrationsControllerDelete(programId: number, page?: boolean, limit?: boolean, dryRun?: boolean, filterReferenceId?: Array<string>, filterStatus?: Array<string>, filterId?: Array<string>, filterRegistrationCreatedDate?: Array<string>, filterPhoneNumber?: Array<string>, filterPreferredLanguage?: Array<string>, filterInclusionScore?: Array<string>, filterPaymentAmountMultiplier?: Array<string>, filterFinancialServiceProvider?: Array<string>, filterFspDisplayName?: Array<string>, filterRegistrationProgramId?: Array<string>, filterMaxPayments?: Array<string>, filterPaymentCount?: Array<string>, filterPaymentCountRemaining?: Array<string>, filterPersonAffectedSequence?: Array<string>, filterLastMessageStatus?: Array<string>, filterFailedPayment?: Array<string>, filterWaitingPayment?: Array<string>, filterSuccessPayment?: Array<string>, filterNotYetSentPayment?: Array<string>, sortBy?: Array<number>, search?: string, searchBy?: Array<string>, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<BulkActionResultDto>;
    public registrationsControllerDelete(programId: number, page?: boolean, limit?: boolean, dryRun?: boolean, filterReferenceId?: Array<string>, filterStatus?: Array<string>, filterId?: Array<string>, filterRegistrationCreatedDate?: Array<string>, filterPhoneNumber?: Array<string>, filterPreferredLanguage?: Array<string>, filterInclusionScore?: Array<string>, filterPaymentAmountMultiplier?: Array<string>, filterFinancialServiceProvider?: Array<string>, filterFspDisplayName?: Array<string>, filterRegistrationProgramId?: Array<string>, filterMaxPayments?: Array<string>, filterPaymentCount?: Array<string>, filterPaymentCountRemaining?: Array<string>, filterPersonAffectedSequence?: Array<string>, filterLastMessageStatus?: Array<string>, filterFailedPayment?: Array<string>, filterWaitingPayment?: Array<string>, filterSuccessPayment?: Array<string>, filterNotYetSentPayment?: Array<string>, sortBy?: Array<number>, search?: string, searchBy?: Array<string>, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<BulkActionResultDto>>;
    public registrationsControllerDelete(programId: number, page?: boolean, limit?: boolean, dryRun?: boolean, filterReferenceId?: Array<string>, filterStatus?: Array<string>, filterId?: Array<string>, filterRegistrationCreatedDate?: Array<string>, filterPhoneNumber?: Array<string>, filterPreferredLanguage?: Array<string>, filterInclusionScore?: Array<string>, filterPaymentAmountMultiplier?: Array<string>, filterFinancialServiceProvider?: Array<string>, filterFspDisplayName?: Array<string>, filterRegistrationProgramId?: Array<string>, filterMaxPayments?: Array<string>, filterPaymentCount?: Array<string>, filterPaymentCountRemaining?: Array<string>, filterPersonAffectedSequence?: Array<string>, filterLastMessageStatus?: Array<string>, filterFailedPayment?: Array<string>, filterWaitingPayment?: Array<string>, filterSuccessPayment?: Array<string>, filterNotYetSentPayment?: Array<string>, sortBy?: Array<number>, search?: string, searchBy?: Array<string>, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<BulkActionResultDto>>;
    public registrationsControllerDelete(programId: number, page?: boolean, limit?: boolean, dryRun?: boolean, filterReferenceId?: Array<string>, filterStatus?: Array<string>, filterId?: Array<string>, filterRegistrationCreatedDate?: Array<string>, filterPhoneNumber?: Array<string>, filterPreferredLanguage?: Array<string>, filterInclusionScore?: Array<string>, filterPaymentAmountMultiplier?: Array<string>, filterFinancialServiceProvider?: Array<string>, filterFspDisplayName?: Array<string>, filterRegistrationProgramId?: Array<string>, filterMaxPayments?: Array<string>, filterPaymentCount?: Array<string>, filterPaymentCountRemaining?: Array<string>, filterPersonAffectedSequence?: Array<string>, filterLastMessageStatus?: Array<string>, filterFailedPayment?: Array<string>, filterWaitingPayment?: Array<string>, filterSuccessPayment?: Array<string>, filterNotYetSentPayment?: Array<string>, sortBy?: Array<number>, search?: string, searchBy?: Array<string>, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {
        if (programId === null || programId === undefined) {
            throw new Error('Required parameter programId was null or undefined when calling registrationsControllerDelete.');
        }

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (page !== undefined && page !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>page, 'page');
        }
        if (limit !== undefined && limit !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>limit, 'limit');
        }
        if (dryRun !== undefined && dryRun !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>dryRun, 'dryRun');
        }
        if (filterReferenceId) {
            filterReferenceId.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'filter.referenceId');
            })
        }
        if (filterStatus) {
            filterStatus.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'filter.status');
            })
        }
        if (filterId) {
            filterId.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'filter.id');
            })
        }
        if (filterRegistrationCreatedDate) {
            filterRegistrationCreatedDate.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'filter.registrationCreatedDate');
            })
        }
        if (filterPhoneNumber) {
            filterPhoneNumber.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'filter.phoneNumber');
            })
        }
        if (filterPreferredLanguage) {
            filterPreferredLanguage.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'filter.preferredLanguage');
            })
        }
        if (filterInclusionScore) {
            filterInclusionScore.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'filter.inclusionScore');
            })
        }
        if (filterPaymentAmountMultiplier) {
            filterPaymentAmountMultiplier.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'filter.paymentAmountMultiplier');
            })
        }
        if (filterFinancialServiceProvider) {
            filterFinancialServiceProvider.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'filter.financialServiceProvider');
            })
        }
        if (filterFspDisplayName) {
            filterFspDisplayName.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'filter.fspDisplayName');
            })
        }
        if (filterRegistrationProgramId) {
            filterRegistrationProgramId.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'filter.registrationProgramId');
            })
        }
        if (filterMaxPayments) {
            filterMaxPayments.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'filter.maxPayments');
            })
        }
        if (filterPaymentCount) {
            filterPaymentCount.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'filter.paymentCount');
            })
        }
        if (filterPaymentCountRemaining) {
            filterPaymentCountRemaining.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'filter.paymentCountRemaining');
            })
        }
        if (filterPersonAffectedSequence) {
            filterPersonAffectedSequence.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'filter.personAffectedSequence');
            })
        }
        if (filterLastMessageStatus) {
            filterLastMessageStatus.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'filter.lastMessageStatus');
            })
        }
        if (filterFailedPayment) {
            filterFailedPayment.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'filter.failedPayment');
            })
        }
        if (filterWaitingPayment) {
            filterWaitingPayment.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'filter.waitingPayment');
            })
        }
        if (filterSuccessPayment) {
            filterSuccessPayment.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'filter.successPayment');
            })
        }
        if (filterNotYetSentPayment) {
            filterNotYetSentPayment.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'filter.notYetSentPayment');
            })
        }
        if (sortBy) {
            sortBy.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'sortBy');
            })
        }
        if (search !== undefined && search !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>search, 'search');
        }
        if (searchBy) {
            searchBy.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'searchBy');
            })
        }

        let localVarHeaders = this.defaultHeaders;

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }

        let localVarTransferCache: boolean | undefined = options && options.transferCache;
        if (localVarTransferCache === undefined) {
            localVarTransferCache = true;
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/api/programs/${this.configuration.encodeParam({name: "programId", value: programId, in: "path", style: "simple", explode: false, dataType: "number", dataFormat: undefined})}/registrations`;
        return this.httpClient.request<BulkActionResultDto>('delete', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                transferCache: localVarTransferCache,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * [SCOPED] Get paginated registrations. Below you will find all the default paginate options, including filtering on any generic fields. NOTE: additionally you can filter on program-specific fields, like program questions, fsp questions, and custom attributes, even though not specified in the Swagger Docs.
     * @param programId 
     * @param page Page number to retrieve.If you provide invalid value the default page number will applied         &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; 1           &lt;/p&gt;         &lt;p&gt;              &lt;b&gt;Default Value: &lt;/b&gt; 1           &lt;/p&gt;         
     * @param limit Number of records per page.       &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; 20           &lt;/p&gt;       &lt;p&gt;              &lt;b&gt;Default Value: &lt;/b&gt; 20           &lt;/p&gt;       &lt;p&gt;              &lt;b&gt;Max Value: &lt;/b&gt; 40000           &lt;/p&gt;        If provided value is greater than max value, max value will be applied.       
     * @param filterReferenceId Filter by referenceId query param.           &lt;p&gt;              &lt;b&gt;Format: &lt;/b&gt; filter.referenceId&#x3D;{$not}:OPERATION:VALUE           &lt;/p&gt;           &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; filter.referenceId&#x3D;$not:$like:John Doe&amp;filter.referenceId&#x3D;like:John           &lt;/p&gt;           &lt;h4&gt;Available Operations&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;$eq&lt;/li&gt; &lt;li&gt;$in&lt;/li&gt; &lt;li&gt;$ilike&lt;/li&gt; &lt;li&gt;$null&lt;/li&gt;&lt;/ul&gt;
     * @param filterStatus Filter by status query param.           &lt;p&gt;              &lt;b&gt;Format: &lt;/b&gt; filter.status&#x3D;{$not}:OPERATION:VALUE           &lt;/p&gt;           &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; filter.status&#x3D;$not:$like:John Doe&amp;filter.status&#x3D;like:John           &lt;/p&gt;           &lt;h4&gt;Available Operations&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;$eq&lt;/li&gt; &lt;li&gt;$in&lt;/li&gt; &lt;li&gt;$ilike&lt;/li&gt; &lt;li&gt;$null&lt;/li&gt;&lt;/ul&gt;
     * @param filterId Filter by id query param.           &lt;p&gt;              &lt;b&gt;Format: &lt;/b&gt; filter.id&#x3D;{$not}:OPERATION:VALUE           &lt;/p&gt;           &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; filter.id&#x3D;$not:$like:John Doe&amp;filter.id&#x3D;like:John           &lt;/p&gt;           &lt;h4&gt;Available Operations&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;$eq&lt;/li&gt; &lt;li&gt;$null&lt;/li&gt;&lt;/ul&gt;
     * @param filterRegistrationCreatedDate Filter by registrationCreatedDate query param.           &lt;p&gt;              &lt;b&gt;Format: &lt;/b&gt; filter.registrationCreatedDate&#x3D;{$not}:OPERATION:VALUE           &lt;/p&gt;           &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; filter.registrationCreatedDate&#x3D;$not:$like:John Doe&amp;filter.registrationCreatedDate&#x3D;like:John           &lt;/p&gt;           &lt;h4&gt;Available Operations&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;$eq&lt;/li&gt; &lt;li&gt;$in&lt;/li&gt; &lt;li&gt;$ilike&lt;/li&gt; &lt;li&gt;$null&lt;/li&gt;&lt;/ul&gt;
     * @param filterPhoneNumber Filter by phoneNumber query param.           &lt;p&gt;              &lt;b&gt;Format: &lt;/b&gt; filter.phoneNumber&#x3D;{$not}:OPERATION:VALUE           &lt;/p&gt;           &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; filter.phoneNumber&#x3D;$not:$like:John Doe&amp;filter.phoneNumber&#x3D;like:John           &lt;/p&gt;           &lt;h4&gt;Available Operations&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;$eq&lt;/li&gt; &lt;li&gt;$in&lt;/li&gt; &lt;li&gt;$ilike&lt;/li&gt; &lt;li&gt;$null&lt;/li&gt;&lt;/ul&gt;
     * @param filterPreferredLanguage Filter by preferredLanguage query param.           &lt;p&gt;              &lt;b&gt;Format: &lt;/b&gt; filter.preferredLanguage&#x3D;{$not}:OPERATION:VALUE           &lt;/p&gt;           &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; filter.preferredLanguage&#x3D;$not:$like:John Doe&amp;filter.preferredLanguage&#x3D;like:John           &lt;/p&gt;           &lt;h4&gt;Available Operations&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;$eq&lt;/li&gt; &lt;li&gt;$in&lt;/li&gt; &lt;li&gt;$ilike&lt;/li&gt; &lt;li&gt;$null&lt;/li&gt;&lt;/ul&gt;
     * @param filterInclusionScore Filter by inclusionScore query param.           &lt;p&gt;              &lt;b&gt;Format: &lt;/b&gt; filter.inclusionScore&#x3D;{$not}:OPERATION:VALUE           &lt;/p&gt;           &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; filter.inclusionScore&#x3D;$not:$like:John Doe&amp;filter.inclusionScore&#x3D;like:John           &lt;/p&gt;           &lt;h4&gt;Available Operations&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;$eq&lt;/li&gt; &lt;li&gt;$null&lt;/li&gt;&lt;/ul&gt;
     * @param filterPaymentAmountMultiplier Filter by paymentAmountMultiplier query param.           &lt;p&gt;              &lt;b&gt;Format: &lt;/b&gt; filter.paymentAmountMultiplier&#x3D;{$not}:OPERATION:VALUE           &lt;/p&gt;           &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; filter.paymentAmountMultiplier&#x3D;$not:$like:John Doe&amp;filter.paymentAmountMultiplier&#x3D;like:John           &lt;/p&gt;           &lt;h4&gt;Available Operations&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;$eq&lt;/li&gt; &lt;li&gt;$null&lt;/li&gt;&lt;/ul&gt;
     * @param filterFinancialServiceProvider Filter by financialServiceProvider query param.           &lt;p&gt;              &lt;b&gt;Format: &lt;/b&gt; filter.financialServiceProvider&#x3D;{$not}:OPERATION:VALUE           &lt;/p&gt;           &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; filter.financialServiceProvider&#x3D;$not:$like:John Doe&amp;filter.financialServiceProvider&#x3D;like:John           &lt;/p&gt;           &lt;h4&gt;Available Operations&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;$eq&lt;/li&gt; &lt;li&gt;$in&lt;/li&gt; &lt;li&gt;$ilike&lt;/li&gt; &lt;li&gt;$null&lt;/li&gt;&lt;/ul&gt;
     * @param filterFspDisplayName Filter by fspDisplayName query param.           &lt;p&gt;              &lt;b&gt;Format: &lt;/b&gt; filter.fspDisplayName&#x3D;{$not}:OPERATION:VALUE           &lt;/p&gt;           &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; filter.fspDisplayName&#x3D;$not:$like:John Doe&amp;filter.fspDisplayName&#x3D;like:John           &lt;/p&gt;           &lt;h4&gt;Available Operations&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;$eq&lt;/li&gt; &lt;li&gt;$in&lt;/li&gt; &lt;li&gt;$ilike&lt;/li&gt; &lt;li&gt;$null&lt;/li&gt;&lt;/ul&gt;
     * @param filterRegistrationProgramId Filter by registrationProgramId query param.           &lt;p&gt;              &lt;b&gt;Format: &lt;/b&gt; filter.registrationProgramId&#x3D;{$not}:OPERATION:VALUE           &lt;/p&gt;           &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; filter.registrationProgramId&#x3D;$not:$like:John Doe&amp;filter.registrationProgramId&#x3D;like:John           &lt;/p&gt;           &lt;h4&gt;Available Operations&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;$eq&lt;/li&gt; &lt;li&gt;$null&lt;/li&gt;&lt;/ul&gt;
     * @param filterMaxPayments Filter by maxPayments query param.           &lt;p&gt;              &lt;b&gt;Format: &lt;/b&gt; filter.maxPayments&#x3D;{$not}:OPERATION:VALUE           &lt;/p&gt;           &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; filter.maxPayments&#x3D;$not:$like:John Doe&amp;filter.maxPayments&#x3D;like:John           &lt;/p&gt;           &lt;h4&gt;Available Operations&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;$eq&lt;/li&gt; &lt;li&gt;$null&lt;/li&gt;&lt;/ul&gt;
     * @param filterPaymentCount Filter by paymentCount query param.           &lt;p&gt;              &lt;b&gt;Format: &lt;/b&gt; filter.paymentCount&#x3D;{$not}:OPERATION:VALUE           &lt;/p&gt;           &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; filter.paymentCount&#x3D;$not:$like:John Doe&amp;filter.paymentCount&#x3D;like:John           &lt;/p&gt;           &lt;h4&gt;Available Operations&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;$eq&lt;/li&gt; &lt;li&gt;$null&lt;/li&gt;&lt;/ul&gt;
     * @param filterPaymentCountRemaining Filter by paymentCountRemaining query param.           &lt;p&gt;              &lt;b&gt;Format: &lt;/b&gt; filter.paymentCountRemaining&#x3D;{$not}:OPERATION:VALUE           &lt;/p&gt;           &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; filter.paymentCountRemaining&#x3D;$not:$like:John Doe&amp;filter.paymentCountRemaining&#x3D;like:John           &lt;/p&gt;           &lt;h4&gt;Available Operations&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;$eq&lt;/li&gt; &lt;li&gt;$null&lt;/li&gt;&lt;/ul&gt;
     * @param filterPersonAffectedSequence Filter by personAffectedSequence query param.           &lt;p&gt;              &lt;b&gt;Format: &lt;/b&gt; filter.personAffectedSequence&#x3D;{$not}:OPERATION:VALUE           &lt;/p&gt;           &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; filter.personAffectedSequence&#x3D;$not:$like:John Doe&amp;filter.personAffectedSequence&#x3D;like:John           &lt;/p&gt;           &lt;h4&gt;Available Operations&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;$eq&lt;/li&gt; &lt;li&gt;$in&lt;/li&gt; &lt;li&gt;$ilike&lt;/li&gt; &lt;li&gt;$null&lt;/li&gt;&lt;/ul&gt;
     * @param filterLastMessageStatus Filter by lastMessageStatus query param.           &lt;p&gt;              &lt;b&gt;Format: &lt;/b&gt; filter.lastMessageStatus&#x3D;{$not}:OPERATION:VALUE           &lt;/p&gt;           &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; filter.lastMessageStatus&#x3D;$not:$like:John Doe&amp;filter.lastMessageStatus&#x3D;like:John           &lt;/p&gt;           &lt;h4&gt;Available Operations&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;$eq&lt;/li&gt; &lt;li&gt;$in&lt;/li&gt; &lt;li&gt;$ilike&lt;/li&gt; &lt;li&gt;$null&lt;/li&gt;&lt;/ul&gt;
     * @param filterFailedPayment Filter by failedPayment query param.           &lt;p&gt;              &lt;b&gt;Format: &lt;/b&gt; filter.failedPayment&#x3D;{$not}:OPERATION:VALUE           &lt;/p&gt;           &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; filter.failedPayment&#x3D;$not:$like:John Doe&amp;filter.failedPayment&#x3D;like:John           &lt;/p&gt;           &lt;h4&gt;Available Operations&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;$eq&lt;/li&gt; &lt;li&gt;$null&lt;/li&gt;&lt;/ul&gt;
     * @param filterWaitingPayment Filter by waitingPayment query param.           &lt;p&gt;              &lt;b&gt;Format: &lt;/b&gt; filter.waitingPayment&#x3D;{$not}:OPERATION:VALUE           &lt;/p&gt;           &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; filter.waitingPayment&#x3D;$not:$like:John Doe&amp;filter.waitingPayment&#x3D;like:John           &lt;/p&gt;           &lt;h4&gt;Available Operations&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;$eq&lt;/li&gt; &lt;li&gt;$null&lt;/li&gt;&lt;/ul&gt;
     * @param filterSuccessPayment Filter by successPayment query param.           &lt;p&gt;              &lt;b&gt;Format: &lt;/b&gt; filter.successPayment&#x3D;{$not}:OPERATION:VALUE           &lt;/p&gt;           &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; filter.successPayment&#x3D;$not:$like:John Doe&amp;filter.successPayment&#x3D;like:John           &lt;/p&gt;           &lt;h4&gt;Available Operations&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;$eq&lt;/li&gt; &lt;li&gt;$null&lt;/li&gt;&lt;/ul&gt;
     * @param filterNotYetSentPayment Filter by notYetSentPayment query param.           &lt;p&gt;              &lt;b&gt;Format: &lt;/b&gt; filter.notYetSentPayment&#x3D;{$not}:OPERATION:VALUE           &lt;/p&gt;           &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; filter.notYetSentPayment&#x3D;$not:$like:John Doe&amp;filter.notYetSentPayment&#x3D;like:John           &lt;/p&gt;           &lt;h4&gt;Available Operations&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;$eq&lt;/li&gt; &lt;li&gt;$null&lt;/li&gt;&lt;/ul&gt;
     * @param sortBy Parameter to sort by.       &lt;p&gt;To sort by multiple fields, just provide query param multiple types. The order in url defines an order of sorting&lt;/p&gt;       &lt;p&gt;              &lt;b&gt;Format: &lt;/b&gt; fieldName:DIRECTION           &lt;/p&gt;       &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; sortBy&#x3D;id:DESC&amp;sortBy&#x3D;createdAt:ASC           &lt;/p&gt;       &lt;p&gt;              &lt;b&gt;Default Value: &lt;/b&gt; No default sorting specified, the result order is not guaranteed           &lt;/p&gt;       &lt;h4&gt;Available Fields&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;id&lt;/li&gt; &lt;li&gt;registrationCreated&lt;/li&gt; &lt;li&gt;status&lt;/li&gt; &lt;li&gt;referenceId&lt;/li&gt; &lt;li&gt;phoneNumber&lt;/li&gt; &lt;li&gt;preferredLanguage&lt;/li&gt; &lt;li&gt;inclusionScore&lt;/li&gt; &lt;li&gt;paymentAmountMultiplier&lt;/li&gt; &lt;li&gt;financialServiceProvider&lt;/li&gt; &lt;li&gt;registrationProgramId&lt;/li&gt; &lt;li&gt;personAffectedSequence&lt;/li&gt; &lt;li&gt;maxPayments&lt;/li&gt; &lt;li&gt;paymentCount&lt;/li&gt; &lt;li&gt;paymentCountRemaining&lt;/li&gt; &lt;li&gt;lastMessageStatus&lt;/li&gt; &lt;li&gt;data.(value)&lt;/li&gt;&lt;/ul&gt;       
     * @param search Search term to filter result values         &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; John           &lt;/p&gt;         &lt;p&gt;              &lt;b&gt;Default Value: &lt;/b&gt; No default value           &lt;/p&gt;         
     * @param searchBy List of fields to search by term to filter result values         &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; data.(value)           &lt;/p&gt;         &lt;p&gt;              &lt;b&gt;Default Value: &lt;/b&gt; By default all fields mentioned below will be used to search by term           &lt;/p&gt;         &lt;h4&gt;Available Fields&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;data.(value)&lt;/li&gt;&lt;/ul&gt;         
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public registrationsControllerFindAll(programId: number, page?: number, limit?: number, filterReferenceId?: Array<string>, filterStatus?: Array<string>, filterId?: Array<string>, filterRegistrationCreatedDate?: Array<string>, filterPhoneNumber?: Array<string>, filterPreferredLanguage?: Array<string>, filterInclusionScore?: Array<string>, filterPaymentAmountMultiplier?: Array<string>, filterFinancialServiceProvider?: Array<string>, filterFspDisplayName?: Array<string>, filterRegistrationProgramId?: Array<string>, filterMaxPayments?: Array<string>, filterPaymentCount?: Array<string>, filterPaymentCountRemaining?: Array<string>, filterPersonAffectedSequence?: Array<string>, filterLastMessageStatus?: Array<string>, filterFailedPayment?: Array<string>, filterWaitingPayment?: Array<string>, filterSuccessPayment?: Array<string>, filterNotYetSentPayment?: Array<string>, sortBy?: Array<'id:ASC' | 'id:DESC' | 'registrationCreated:ASC' | 'registrationCreated:DESC' | 'status:ASC' | 'status:DESC' | 'referenceId:ASC' | 'referenceId:DESC' | 'phoneNumber:ASC' | 'phoneNumber:DESC' | 'preferredLanguage:ASC' | 'preferredLanguage:DESC' | 'inclusionScore:ASC' | 'inclusionScore:DESC' | 'paymentAmountMultiplier:ASC' | 'paymentAmountMultiplier:DESC' | 'financialServiceProvider:ASC' | 'financialServiceProvider:DESC' | 'registrationProgramId:ASC' | 'registrationProgramId:DESC' | 'personAffectedSequence:ASC' | 'personAffectedSequence:DESC' | 'maxPayments:ASC' | 'maxPayments:DESC' | 'paymentCount:ASC' | 'paymentCount:DESC' | 'paymentCountRemaining:ASC' | 'paymentCountRemaining:DESC' | 'lastMessageStatus:ASC' | 'lastMessageStatus:DESC' | 'data.(value):ASC' | 'data.(value):DESC'>, search?: string, searchBy?: Array<string>, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<RegistrationsControllerFindAll200Response>;
    public registrationsControllerFindAll(programId: number, page?: number, limit?: number, filterReferenceId?: Array<string>, filterStatus?: Array<string>, filterId?: Array<string>, filterRegistrationCreatedDate?: Array<string>, filterPhoneNumber?: Array<string>, filterPreferredLanguage?: Array<string>, filterInclusionScore?: Array<string>, filterPaymentAmountMultiplier?: Array<string>, filterFinancialServiceProvider?: Array<string>, filterFspDisplayName?: Array<string>, filterRegistrationProgramId?: Array<string>, filterMaxPayments?: Array<string>, filterPaymentCount?: Array<string>, filterPaymentCountRemaining?: Array<string>, filterPersonAffectedSequence?: Array<string>, filterLastMessageStatus?: Array<string>, filterFailedPayment?: Array<string>, filterWaitingPayment?: Array<string>, filterSuccessPayment?: Array<string>, filterNotYetSentPayment?: Array<string>, sortBy?: Array<'id:ASC' | 'id:DESC' | 'registrationCreated:ASC' | 'registrationCreated:DESC' | 'status:ASC' | 'status:DESC' | 'referenceId:ASC' | 'referenceId:DESC' | 'phoneNumber:ASC' | 'phoneNumber:DESC' | 'preferredLanguage:ASC' | 'preferredLanguage:DESC' | 'inclusionScore:ASC' | 'inclusionScore:DESC' | 'paymentAmountMultiplier:ASC' | 'paymentAmountMultiplier:DESC' | 'financialServiceProvider:ASC' | 'financialServiceProvider:DESC' | 'registrationProgramId:ASC' | 'registrationProgramId:DESC' | 'personAffectedSequence:ASC' | 'personAffectedSequence:DESC' | 'maxPayments:ASC' | 'maxPayments:DESC' | 'paymentCount:ASC' | 'paymentCount:DESC' | 'paymentCountRemaining:ASC' | 'paymentCountRemaining:DESC' | 'lastMessageStatus:ASC' | 'lastMessageStatus:DESC' | 'data.(value):ASC' | 'data.(value):DESC'>, search?: string, searchBy?: Array<string>, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<RegistrationsControllerFindAll200Response>>;
    public registrationsControllerFindAll(programId: number, page?: number, limit?: number, filterReferenceId?: Array<string>, filterStatus?: Array<string>, filterId?: Array<string>, filterRegistrationCreatedDate?: Array<string>, filterPhoneNumber?: Array<string>, filterPreferredLanguage?: Array<string>, filterInclusionScore?: Array<string>, filterPaymentAmountMultiplier?: Array<string>, filterFinancialServiceProvider?: Array<string>, filterFspDisplayName?: Array<string>, filterRegistrationProgramId?: Array<string>, filterMaxPayments?: Array<string>, filterPaymentCount?: Array<string>, filterPaymentCountRemaining?: Array<string>, filterPersonAffectedSequence?: Array<string>, filterLastMessageStatus?: Array<string>, filterFailedPayment?: Array<string>, filterWaitingPayment?: Array<string>, filterSuccessPayment?: Array<string>, filterNotYetSentPayment?: Array<string>, sortBy?: Array<'id:ASC' | 'id:DESC' | 'registrationCreated:ASC' | 'registrationCreated:DESC' | 'status:ASC' | 'status:DESC' | 'referenceId:ASC' | 'referenceId:DESC' | 'phoneNumber:ASC' | 'phoneNumber:DESC' | 'preferredLanguage:ASC' | 'preferredLanguage:DESC' | 'inclusionScore:ASC' | 'inclusionScore:DESC' | 'paymentAmountMultiplier:ASC' | 'paymentAmountMultiplier:DESC' | 'financialServiceProvider:ASC' | 'financialServiceProvider:DESC' | 'registrationProgramId:ASC' | 'registrationProgramId:DESC' | 'personAffectedSequence:ASC' | 'personAffectedSequence:DESC' | 'maxPayments:ASC' | 'maxPayments:DESC' | 'paymentCount:ASC' | 'paymentCount:DESC' | 'paymentCountRemaining:ASC' | 'paymentCountRemaining:DESC' | 'lastMessageStatus:ASC' | 'lastMessageStatus:DESC' | 'data.(value):ASC' | 'data.(value):DESC'>, search?: string, searchBy?: Array<string>, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<RegistrationsControllerFindAll200Response>>;
    public registrationsControllerFindAll(programId: number, page?: number, limit?: number, filterReferenceId?: Array<string>, filterStatus?: Array<string>, filterId?: Array<string>, filterRegistrationCreatedDate?: Array<string>, filterPhoneNumber?: Array<string>, filterPreferredLanguage?: Array<string>, filterInclusionScore?: Array<string>, filterPaymentAmountMultiplier?: Array<string>, filterFinancialServiceProvider?: Array<string>, filterFspDisplayName?: Array<string>, filterRegistrationProgramId?: Array<string>, filterMaxPayments?: Array<string>, filterPaymentCount?: Array<string>, filterPaymentCountRemaining?: Array<string>, filterPersonAffectedSequence?: Array<string>, filterLastMessageStatus?: Array<string>, filterFailedPayment?: Array<string>, filterWaitingPayment?: Array<string>, filterSuccessPayment?: Array<string>, filterNotYetSentPayment?: Array<string>, sortBy?: Array<'id:ASC' | 'id:DESC' | 'registrationCreated:ASC' | 'registrationCreated:DESC' | 'status:ASC' | 'status:DESC' | 'referenceId:ASC' | 'referenceId:DESC' | 'phoneNumber:ASC' | 'phoneNumber:DESC' | 'preferredLanguage:ASC' | 'preferredLanguage:DESC' | 'inclusionScore:ASC' | 'inclusionScore:DESC' | 'paymentAmountMultiplier:ASC' | 'paymentAmountMultiplier:DESC' | 'financialServiceProvider:ASC' | 'financialServiceProvider:DESC' | 'registrationProgramId:ASC' | 'registrationProgramId:DESC' | 'personAffectedSequence:ASC' | 'personAffectedSequence:DESC' | 'maxPayments:ASC' | 'maxPayments:DESC' | 'paymentCount:ASC' | 'paymentCount:DESC' | 'paymentCountRemaining:ASC' | 'paymentCountRemaining:DESC' | 'lastMessageStatus:ASC' | 'lastMessageStatus:DESC' | 'data.(value):ASC' | 'data.(value):DESC'>, search?: string, searchBy?: Array<string>, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {
        if (programId === null || programId === undefined) {
            throw new Error('Required parameter programId was null or undefined when calling registrationsControllerFindAll.');
        }

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (page !== undefined && page !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>page, 'page');
        }
        if (limit !== undefined && limit !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>limit, 'limit');
        }
        if (filterReferenceId) {
            filterReferenceId.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'filter.referenceId');
            })
        }
        if (filterStatus) {
            filterStatus.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'filter.status');
            })
        }
        if (filterId) {
            filterId.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'filter.id');
            })
        }
        if (filterRegistrationCreatedDate) {
            filterRegistrationCreatedDate.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'filter.registrationCreatedDate');
            })
        }
        if (filterPhoneNumber) {
            filterPhoneNumber.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'filter.phoneNumber');
            })
        }
        if (filterPreferredLanguage) {
            filterPreferredLanguage.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'filter.preferredLanguage');
            })
        }
        if (filterInclusionScore) {
            filterInclusionScore.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'filter.inclusionScore');
            })
        }
        if (filterPaymentAmountMultiplier) {
            filterPaymentAmountMultiplier.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'filter.paymentAmountMultiplier');
            })
        }
        if (filterFinancialServiceProvider) {
            filterFinancialServiceProvider.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'filter.financialServiceProvider');
            })
        }
        if (filterFspDisplayName) {
            filterFspDisplayName.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'filter.fspDisplayName');
            })
        }
        if (filterRegistrationProgramId) {
            filterRegistrationProgramId.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'filter.registrationProgramId');
            })
        }
        if (filterMaxPayments) {
            filterMaxPayments.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'filter.maxPayments');
            })
        }
        if (filterPaymentCount) {
            filterPaymentCount.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'filter.paymentCount');
            })
        }
        if (filterPaymentCountRemaining) {
            filterPaymentCountRemaining.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'filter.paymentCountRemaining');
            })
        }
        if (filterPersonAffectedSequence) {
            filterPersonAffectedSequence.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'filter.personAffectedSequence');
            })
        }
        if (filterLastMessageStatus) {
            filterLastMessageStatus.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'filter.lastMessageStatus');
            })
        }
        if (filterFailedPayment) {
            filterFailedPayment.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'filter.failedPayment');
            })
        }
        if (filterWaitingPayment) {
            filterWaitingPayment.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'filter.waitingPayment');
            })
        }
        if (filterSuccessPayment) {
            filterSuccessPayment.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'filter.successPayment');
            })
        }
        if (filterNotYetSentPayment) {
            filterNotYetSentPayment.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'filter.notYetSentPayment');
            })
        }
        if (sortBy) {
            sortBy.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'sortBy');
            })
        }
        if (search !== undefined && search !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>search, 'search');
        }
        if (searchBy) {
            searchBy.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'searchBy');
            })
        }

        let localVarHeaders = this.defaultHeaders;

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }

        let localVarTransferCache: boolean | undefined = options && options.transferCache;
        if (localVarTransferCache === undefined) {
            localVarTransferCache = true;
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/api/programs/${this.configuration.encodeParam({name: "programId", value: programId, in: "path", style: "simple", explode: false, dataType: "number", dataFormat: undefined})}/registrations`;
        return this.httpClient.request<RegistrationsControllerFindAll200Response>('get', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                transferCache: localVarTransferCache,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Get a CSV template for importing registrations
     * @param programId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public registrationsControllerGetImportRegistrationsTemplate(programId: number, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined, context?: HttpContext, transferCache?: boolean}): Observable<any>;
    public registrationsControllerGetImportRegistrationsTemplate(programId: number, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined, context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<any>>;
    public registrationsControllerGetImportRegistrationsTemplate(programId: number, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined, context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<any>>;
    public registrationsControllerGetImportRegistrationsTemplate(programId: number, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: undefined, context?: HttpContext, transferCache?: boolean}): Observable<any> {
        if (programId === null || programId === undefined) {
            throw new Error('Required parameter programId was null or undefined when calling registrationsControllerGetImportRegistrationsTemplate.');
        }

        let localVarHeaders = this.defaultHeaders;

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }

        let localVarTransferCache: boolean | undefined = options && options.transferCache;
        if (localVarTransferCache === undefined) {
            localVarTransferCache = true;
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/api/programs/${this.configuration.encodeParam({name: "programId", value: programId, in: "path", style: "simple", explode: false, dataType: "number", dataFormat: undefined})}/registrations/import-template`;
        return this.httpClient.request<any>('get', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                transferCache: localVarTransferCache,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * [SCOPED] Get message history for one registration
     * @param referenceId 
     * @param programId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public registrationsControllerGetMessageHistoryRegistration(referenceId: string, programId: number, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined, context?: HttpContext, transferCache?: boolean}): Observable<any>;
    public registrationsControllerGetMessageHistoryRegistration(referenceId: string, programId: number, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined, context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<any>>;
    public registrationsControllerGetMessageHistoryRegistration(referenceId: string, programId: number, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined, context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<any>>;
    public registrationsControllerGetMessageHistoryRegistration(referenceId: string, programId: number, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: undefined, context?: HttpContext, transferCache?: boolean}): Observable<any> {
        if (referenceId === null || referenceId === undefined) {
            throw new Error('Required parameter referenceId was null or undefined when calling registrationsControllerGetMessageHistoryRegistration.');
        }
        if (programId === null || programId === undefined) {
            throw new Error('Required parameter programId was null or undefined when calling registrationsControllerGetMessageHistoryRegistration.');
        }

        let localVarHeaders = this.defaultHeaders;

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }

        let localVarTransferCache: boolean | undefined = options && options.transferCache;
        if (localVarTransferCache === undefined) {
            localVarTransferCache = true;
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/api/programs/${this.configuration.encodeParam({name: "programId", value: programId, in: "path", style: "simple", explode: false, dataType: "number", dataFormat: undefined})}/registrations/message-history/${this.configuration.encodeParam({name: "referenceId", value: referenceId, in: "path", style: "simple", explode: false, dataType: "string", dataFormat: undefined})}`;
        return this.httpClient.request<any>('get', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                transferCache: localVarTransferCache,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * [SCOPED] Get Person Affected referenceId
     * @param paId 
     * @param programId 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public registrationsControllerGetReferenceId(paId: number, programId: number, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined, context?: HttpContext, transferCache?: boolean}): Observable<any>;
    public registrationsControllerGetReferenceId(paId: number, programId: number, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined, context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<any>>;
    public registrationsControllerGetReferenceId(paId: number, programId: number, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined, context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<any>>;
    public registrationsControllerGetReferenceId(paId: number, programId: number, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: undefined, context?: HttpContext, transferCache?: boolean}): Observable<any> {
        if (paId === null || paId === undefined) {
            throw new Error('Required parameter paId was null or undefined when calling registrationsControllerGetReferenceId.');
        }
        if (programId === null || programId === undefined) {
            throw new Error('Required parameter programId was null or undefined when calling registrationsControllerGetReferenceId.');
        }

        let localVarHeaders = this.defaultHeaders;

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }

        let localVarTransferCache: boolean | undefined = options && options.transferCache;
        if (localVarTransferCache === undefined) {
            localVarTransferCache = true;
        }


        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/api/programs/${this.configuration.encodeParam({name: "programId", value: programId, in: "path", style: "simple", explode: false, dataType: "number", dataFormat: undefined})}/registrations/referenceid/${this.configuration.encodeParam({name: "paId", value: paId, in: "path", style: "simple", explode: false, dataType: "number", dataFormat: undefined})}`;
        return this.httpClient.request<any>('get', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                transferCache: localVarTransferCache,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Import set of registered PAs, from CSV
     * @param programId 
     * @param file 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public registrationsControllerImportRegistrations(programId: number, file?: Blob, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined, context?: HttpContext, transferCache?: boolean}): Observable<any>;
    public registrationsControllerImportRegistrations(programId: number, file?: Blob, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined, context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<any>>;
    public registrationsControllerImportRegistrations(programId: number, file?: Blob, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined, context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<any>>;
    public registrationsControllerImportRegistrations(programId: number, file?: Blob, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: undefined, context?: HttpContext, transferCache?: boolean}): Observable<any> {
        if (programId === null || programId === undefined) {
            throw new Error('Required parameter programId was null or undefined when calling registrationsControllerImportRegistrations.');
        }

        let localVarHeaders = this.defaultHeaders;

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }

        let localVarTransferCache: boolean | undefined = options && options.transferCache;
        if (localVarTransferCache === undefined) {
            localVarTransferCache = true;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'multipart/form-data'
        ];

        const canConsumeForm = this.canConsumeForm(consumes);

        let localVarFormParams: { append(param: string, value: any): any; };
        let localVarUseForm = false;
        let localVarConvertFormParamsToString = false;
        // use FormData to transmit files using content-type "multipart/form-data"
        // see https://stackoverflow.com/questions/4007969/application-x-www-form-urlencoded-or-multipart-form-data
        localVarUseForm = canConsumeForm;
        if (localVarUseForm) {
            localVarFormParams = new FormData();
        } else {
            localVarFormParams = new HttpParams({encoder: this.encoder});
        }

        if (file !== undefined) {
            localVarFormParams = localVarFormParams.append('file', <any>file) as any || localVarFormParams;
        }

        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/api/programs/${this.configuration.encodeParam({name: "programId", value: programId, in: "path", style: "simple", explode: false, dataType: "number", dataFormat: undefined})}/registrations/import-registrations`;
        return this.httpClient.request<any>('post', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                body: localVarConvertFormParamsToString ? localVarFormParams.toString() : localVarFormParams,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                transferCache: localVarTransferCache,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * [EXTERNALLY USED] Import set of registered PAs
     * Use this endpoint to create new registrations in a specific program. Note that the attributes depend on the program configuration. Authenticate first using the /login endpoint.
     * @param programId 
     * @param importRegistrationsDto 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public registrationsControllerImportRegistrationsJSON(programId: number, importRegistrationsDto: Array<ImportRegistrationsDto>, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined, context?: HttpContext, transferCache?: boolean}): Observable<any>;
    public registrationsControllerImportRegistrationsJSON(programId: number, importRegistrationsDto: Array<ImportRegistrationsDto>, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined, context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<any>>;
    public registrationsControllerImportRegistrationsJSON(programId: number, importRegistrationsDto: Array<ImportRegistrationsDto>, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined, context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<any>>;
    public registrationsControllerImportRegistrationsJSON(programId: number, importRegistrationsDto: Array<ImportRegistrationsDto>, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: undefined, context?: HttpContext, transferCache?: boolean}): Observable<any> {
        if (programId === null || programId === undefined) {
            throw new Error('Required parameter programId was null or undefined when calling registrationsControllerImportRegistrationsJSON.');
        }
        if (importRegistrationsDto === null || importRegistrationsDto === undefined) {
            throw new Error('Required parameter importRegistrationsDto was null or undefined when calling registrationsControllerImportRegistrationsJSON.');
        }

        let localVarHeaders = this.defaultHeaders;

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }

        let localVarTransferCache: boolean | undefined = options && options.transferCache;
        if (localVarTransferCache === undefined) {
            localVarTransferCache = true;
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
        }

        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/api/programs/${this.configuration.encodeParam({name: "programId", value: programId, in: "path", style: "simple", explode: false, dataType: "number", dataFormat: undefined})}/registrations/import`;
        return this.httpClient.request<any>('post', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                body: importRegistrationsDto,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                transferCache: localVarTransferCache,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * Bulk update registration using a CSV file. The columns in the CSV file should contain at least referenceId and the columns you want to update. If you leave a cell empty the corresponding registration data will be update with an empty string. Max file length is 100k rows
     * @param programId 
     * @param file 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public registrationsControllerPatchRegistrations(programId: number, file?: Blob, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined, context?: HttpContext, transferCache?: boolean}): Observable<any>;
    public registrationsControllerPatchRegistrations(programId: number, file?: Blob, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined, context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<any>>;
    public registrationsControllerPatchRegistrations(programId: number, file?: Blob, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined, context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<any>>;
    public registrationsControllerPatchRegistrations(programId: number, file?: Blob, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: undefined, context?: HttpContext, transferCache?: boolean}): Observable<any> {
        if (programId === null || programId === undefined) {
            throw new Error('Required parameter programId was null or undefined when calling registrationsControllerPatchRegistrations.');
        }

        let localVarHeaders = this.defaultHeaders;

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }

        let localVarTransferCache: boolean | undefined = options && options.transferCache;
        if (localVarTransferCache === undefined) {
            localVarTransferCache = true;
        }

        // to determine the Content-Type header
        const consumes: string[] = [
            'multipart/form-data'
        ];

        const canConsumeForm = this.canConsumeForm(consumes);

        let localVarFormParams: { append(param: string, value: any): any; };
        let localVarUseForm = false;
        let localVarConvertFormParamsToString = false;
        // use FormData to transmit files using content-type "multipart/form-data"
        // see https://stackoverflow.com/questions/4007969/application-x-www-form-urlencoded-or-multipart-form-data
        localVarUseForm = canConsumeForm;
        if (localVarUseForm) {
            localVarFormParams = new FormData();
        } else {
            localVarFormParams = new HttpParams({encoder: this.encoder});
        }

        if (file !== undefined) {
            localVarFormParams = localVarFormParams.append('file', <any>file) as any || localVarFormParams;
        }

        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/api/programs/${this.configuration.encodeParam({name: "programId", value: programId, in: "path", style: "simple", explode: false, dataType: "number", dataFormat: undefined})}/registrations`;
        return this.httpClient.request<any>('patch', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                body: localVarConvertFormParamsToString ? localVarFormParams.toString() : localVarFormParams,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                transferCache: localVarTransferCache,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * [SCOPED] [EXTERNALLY USED] Update registration status of set of PAs that can be defined via filter parameters.
     * @param programId 
     * @param registrationStatusPatchDto 
     * @param page Not used for this endpoint
     * @param limit Not used for this endpoint
     * @param dryRun        Only when set explicitly to \&quot;true\&quot;, this will simulate (and NOT actually DO) the action.       Instead it will return how many PA this action can be applied to.       So no registration statuses will be updated or messages will be sent.       
     * @param filterReferenceId Filter by referenceId query param.           &lt;p&gt;              &lt;b&gt;Format: &lt;/b&gt; filter.referenceId&#x3D;{$not}:OPERATION:VALUE           &lt;/p&gt;           &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; filter.referenceId&#x3D;$not:$like:John Doe&amp;filter.referenceId&#x3D;like:John           &lt;/p&gt;           &lt;h4&gt;Available Operations&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;$eq&lt;/li&gt; &lt;li&gt;$in&lt;/li&gt; &lt;li&gt;$ilike&lt;/li&gt; &lt;li&gt;$null&lt;/li&gt;&lt;/ul&gt;
     * @param filterStatus Filter by status query param.           &lt;p&gt;              &lt;b&gt;Format: &lt;/b&gt; filter.status&#x3D;{$not}:OPERATION:VALUE           &lt;/p&gt;           &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; filter.status&#x3D;$not:$like:John Doe&amp;filter.status&#x3D;like:John           &lt;/p&gt;           &lt;h4&gt;Available Operations&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;$eq&lt;/li&gt; &lt;li&gt;$in&lt;/li&gt; &lt;li&gt;$ilike&lt;/li&gt; &lt;li&gt;$null&lt;/li&gt;&lt;/ul&gt;
     * @param filterId Filter by id query param.           &lt;p&gt;              &lt;b&gt;Format: &lt;/b&gt; filter.id&#x3D;{$not}:OPERATION:VALUE           &lt;/p&gt;           &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; filter.id&#x3D;$not:$like:John Doe&amp;filter.id&#x3D;like:John           &lt;/p&gt;           &lt;h4&gt;Available Operations&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;$eq&lt;/li&gt; &lt;li&gt;$null&lt;/li&gt;&lt;/ul&gt;
     * @param filterRegistrationCreatedDate Filter by registrationCreatedDate query param.           &lt;p&gt;              &lt;b&gt;Format: &lt;/b&gt; filter.registrationCreatedDate&#x3D;{$not}:OPERATION:VALUE           &lt;/p&gt;           &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; filter.registrationCreatedDate&#x3D;$not:$like:John Doe&amp;filter.registrationCreatedDate&#x3D;like:John           &lt;/p&gt;           &lt;h4&gt;Available Operations&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;$eq&lt;/li&gt; &lt;li&gt;$in&lt;/li&gt; &lt;li&gt;$ilike&lt;/li&gt; &lt;li&gt;$null&lt;/li&gt;&lt;/ul&gt;
     * @param filterPhoneNumber Filter by phoneNumber query param.           &lt;p&gt;              &lt;b&gt;Format: &lt;/b&gt; filter.phoneNumber&#x3D;{$not}:OPERATION:VALUE           &lt;/p&gt;           &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; filter.phoneNumber&#x3D;$not:$like:John Doe&amp;filter.phoneNumber&#x3D;like:John           &lt;/p&gt;           &lt;h4&gt;Available Operations&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;$eq&lt;/li&gt; &lt;li&gt;$in&lt;/li&gt; &lt;li&gt;$ilike&lt;/li&gt; &lt;li&gt;$null&lt;/li&gt;&lt;/ul&gt;
     * @param filterPreferredLanguage Filter by preferredLanguage query param.           &lt;p&gt;              &lt;b&gt;Format: &lt;/b&gt; filter.preferredLanguage&#x3D;{$not}:OPERATION:VALUE           &lt;/p&gt;           &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; filter.preferredLanguage&#x3D;$not:$like:John Doe&amp;filter.preferredLanguage&#x3D;like:John           &lt;/p&gt;           &lt;h4&gt;Available Operations&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;$eq&lt;/li&gt; &lt;li&gt;$in&lt;/li&gt; &lt;li&gt;$ilike&lt;/li&gt; &lt;li&gt;$null&lt;/li&gt;&lt;/ul&gt;
     * @param filterInclusionScore Filter by inclusionScore query param.           &lt;p&gt;              &lt;b&gt;Format: &lt;/b&gt; filter.inclusionScore&#x3D;{$not}:OPERATION:VALUE           &lt;/p&gt;           &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; filter.inclusionScore&#x3D;$not:$like:John Doe&amp;filter.inclusionScore&#x3D;like:John           &lt;/p&gt;           &lt;h4&gt;Available Operations&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;$eq&lt;/li&gt; &lt;li&gt;$null&lt;/li&gt;&lt;/ul&gt;
     * @param filterPaymentAmountMultiplier Filter by paymentAmountMultiplier query param.           &lt;p&gt;              &lt;b&gt;Format: &lt;/b&gt; filter.paymentAmountMultiplier&#x3D;{$not}:OPERATION:VALUE           &lt;/p&gt;           &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; filter.paymentAmountMultiplier&#x3D;$not:$like:John Doe&amp;filter.paymentAmountMultiplier&#x3D;like:John           &lt;/p&gt;           &lt;h4&gt;Available Operations&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;$eq&lt;/li&gt; &lt;li&gt;$null&lt;/li&gt;&lt;/ul&gt;
     * @param filterFinancialServiceProvider Filter by financialServiceProvider query param.           &lt;p&gt;              &lt;b&gt;Format: &lt;/b&gt; filter.financialServiceProvider&#x3D;{$not}:OPERATION:VALUE           &lt;/p&gt;           &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; filter.financialServiceProvider&#x3D;$not:$like:John Doe&amp;filter.financialServiceProvider&#x3D;like:John           &lt;/p&gt;           &lt;h4&gt;Available Operations&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;$eq&lt;/li&gt; &lt;li&gt;$in&lt;/li&gt; &lt;li&gt;$ilike&lt;/li&gt; &lt;li&gt;$null&lt;/li&gt;&lt;/ul&gt;
     * @param filterFspDisplayName Filter by fspDisplayName query param.           &lt;p&gt;              &lt;b&gt;Format: &lt;/b&gt; filter.fspDisplayName&#x3D;{$not}:OPERATION:VALUE           &lt;/p&gt;           &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; filter.fspDisplayName&#x3D;$not:$like:John Doe&amp;filter.fspDisplayName&#x3D;like:John           &lt;/p&gt;           &lt;h4&gt;Available Operations&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;$eq&lt;/li&gt; &lt;li&gt;$in&lt;/li&gt; &lt;li&gt;$ilike&lt;/li&gt; &lt;li&gt;$null&lt;/li&gt;&lt;/ul&gt;
     * @param filterRegistrationProgramId Filter by registrationProgramId query param.           &lt;p&gt;              &lt;b&gt;Format: &lt;/b&gt; filter.registrationProgramId&#x3D;{$not}:OPERATION:VALUE           &lt;/p&gt;           &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; filter.registrationProgramId&#x3D;$not:$like:John Doe&amp;filter.registrationProgramId&#x3D;like:John           &lt;/p&gt;           &lt;h4&gt;Available Operations&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;$eq&lt;/li&gt; &lt;li&gt;$null&lt;/li&gt;&lt;/ul&gt;
     * @param filterMaxPayments Filter by maxPayments query param.           &lt;p&gt;              &lt;b&gt;Format: &lt;/b&gt; filter.maxPayments&#x3D;{$not}:OPERATION:VALUE           &lt;/p&gt;           &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; filter.maxPayments&#x3D;$not:$like:John Doe&amp;filter.maxPayments&#x3D;like:John           &lt;/p&gt;           &lt;h4&gt;Available Operations&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;$eq&lt;/li&gt; &lt;li&gt;$null&lt;/li&gt;&lt;/ul&gt;
     * @param filterPaymentCount Filter by paymentCount query param.           &lt;p&gt;              &lt;b&gt;Format: &lt;/b&gt; filter.paymentCount&#x3D;{$not}:OPERATION:VALUE           &lt;/p&gt;           &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; filter.paymentCount&#x3D;$not:$like:John Doe&amp;filter.paymentCount&#x3D;like:John           &lt;/p&gt;           &lt;h4&gt;Available Operations&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;$eq&lt;/li&gt; &lt;li&gt;$null&lt;/li&gt;&lt;/ul&gt;
     * @param filterPaymentCountRemaining Filter by paymentCountRemaining query param.           &lt;p&gt;              &lt;b&gt;Format: &lt;/b&gt; filter.paymentCountRemaining&#x3D;{$not}:OPERATION:VALUE           &lt;/p&gt;           &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; filter.paymentCountRemaining&#x3D;$not:$like:John Doe&amp;filter.paymentCountRemaining&#x3D;like:John           &lt;/p&gt;           &lt;h4&gt;Available Operations&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;$eq&lt;/li&gt; &lt;li&gt;$null&lt;/li&gt;&lt;/ul&gt;
     * @param filterPersonAffectedSequence Filter by personAffectedSequence query param.           &lt;p&gt;              &lt;b&gt;Format: &lt;/b&gt; filter.personAffectedSequence&#x3D;{$not}:OPERATION:VALUE           &lt;/p&gt;           &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; filter.personAffectedSequence&#x3D;$not:$like:John Doe&amp;filter.personAffectedSequence&#x3D;like:John           &lt;/p&gt;           &lt;h4&gt;Available Operations&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;$eq&lt;/li&gt; &lt;li&gt;$in&lt;/li&gt; &lt;li&gt;$ilike&lt;/li&gt; &lt;li&gt;$null&lt;/li&gt;&lt;/ul&gt;
     * @param filterLastMessageStatus Filter by lastMessageStatus query param.           &lt;p&gt;              &lt;b&gt;Format: &lt;/b&gt; filter.lastMessageStatus&#x3D;{$not}:OPERATION:VALUE           &lt;/p&gt;           &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; filter.lastMessageStatus&#x3D;$not:$like:John Doe&amp;filter.lastMessageStatus&#x3D;like:John           &lt;/p&gt;           &lt;h4&gt;Available Operations&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;$eq&lt;/li&gt; &lt;li&gt;$in&lt;/li&gt; &lt;li&gt;$ilike&lt;/li&gt; &lt;li&gt;$null&lt;/li&gt;&lt;/ul&gt;
     * @param filterFailedPayment Filter by failedPayment query param.           &lt;p&gt;              &lt;b&gt;Format: &lt;/b&gt; filter.failedPayment&#x3D;{$not}:OPERATION:VALUE           &lt;/p&gt;           &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; filter.failedPayment&#x3D;$not:$like:John Doe&amp;filter.failedPayment&#x3D;like:John           &lt;/p&gt;           &lt;h4&gt;Available Operations&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;$eq&lt;/li&gt; &lt;li&gt;$null&lt;/li&gt;&lt;/ul&gt;
     * @param filterWaitingPayment Filter by waitingPayment query param.           &lt;p&gt;              &lt;b&gt;Format: &lt;/b&gt; filter.waitingPayment&#x3D;{$not}:OPERATION:VALUE           &lt;/p&gt;           &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; filter.waitingPayment&#x3D;$not:$like:John Doe&amp;filter.waitingPayment&#x3D;like:John           &lt;/p&gt;           &lt;h4&gt;Available Operations&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;$eq&lt;/li&gt; &lt;li&gt;$null&lt;/li&gt;&lt;/ul&gt;
     * @param filterSuccessPayment Filter by successPayment query param.           &lt;p&gt;              &lt;b&gt;Format: &lt;/b&gt; filter.successPayment&#x3D;{$not}:OPERATION:VALUE           &lt;/p&gt;           &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; filter.successPayment&#x3D;$not:$like:John Doe&amp;filter.successPayment&#x3D;like:John           &lt;/p&gt;           &lt;h4&gt;Available Operations&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;$eq&lt;/li&gt; &lt;li&gt;$null&lt;/li&gt;&lt;/ul&gt;
     * @param filterNotYetSentPayment Filter by notYetSentPayment query param.           &lt;p&gt;              &lt;b&gt;Format: &lt;/b&gt; filter.notYetSentPayment&#x3D;{$not}:OPERATION:VALUE           &lt;/p&gt;           &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; filter.notYetSentPayment&#x3D;$not:$like:John Doe&amp;filter.notYetSentPayment&#x3D;like:John           &lt;/p&gt;           &lt;h4&gt;Available Operations&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;$eq&lt;/li&gt; &lt;li&gt;$null&lt;/li&gt;&lt;/ul&gt;
     * @param sortBy Parameter to sort by.       &lt;p&gt;To sort by multiple fields, just provide query param multiple types. The order in url defines an order of sorting&lt;/p&gt;       &lt;p&gt;              &lt;b&gt;Format: &lt;/b&gt; fieldName:DIRECTION           &lt;/p&gt;       &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; sortBy&#x3D;id:DESC&amp;sortBy&#x3D;createdAt:ASC           &lt;/p&gt;       &lt;p&gt;              &lt;b&gt;Default Value: &lt;/b&gt; No default sorting specified, the result order is not guaranteed           &lt;/p&gt;       &lt;h4&gt;Available Fields&lt;/h4&gt;&lt;ul&gt;&lt;/ul&gt;       
     * @param search Search term to filter result values         &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; John           &lt;/p&gt;         &lt;p&gt;              &lt;b&gt;Default Value: &lt;/b&gt; No default value           &lt;/p&gt;         
     * @param searchBy List of fields to search by term to filter result values         &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; data.(value)           &lt;/p&gt;         &lt;p&gt;              &lt;b&gt;Default Value: &lt;/b&gt; By default all fields mentioned below will be used to search by term           &lt;/p&gt;         &lt;h4&gt;Available Fields&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;data.(value)&lt;/li&gt;&lt;/ul&gt;         
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public registrationsControllerPatchRegistrationsStatus(programId: number, registrationStatusPatchDto: RegistrationStatusPatchDto, page?: boolean, limit?: boolean, dryRun?: boolean, filterReferenceId?: Array<string>, filterStatus?: Array<string>, filterId?: Array<string>, filterRegistrationCreatedDate?: Array<string>, filterPhoneNumber?: Array<string>, filterPreferredLanguage?: Array<string>, filterInclusionScore?: Array<string>, filterPaymentAmountMultiplier?: Array<string>, filterFinancialServiceProvider?: Array<string>, filterFspDisplayName?: Array<string>, filterRegistrationProgramId?: Array<string>, filterMaxPayments?: Array<string>, filterPaymentCount?: Array<string>, filterPaymentCountRemaining?: Array<string>, filterPersonAffectedSequence?: Array<string>, filterLastMessageStatus?: Array<string>, filterFailedPayment?: Array<string>, filterWaitingPayment?: Array<string>, filterSuccessPayment?: Array<string>, filterNotYetSentPayment?: Array<string>, sortBy?: Array<number>, search?: string, searchBy?: Array<string>, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<BulkActionResultDto>;
    public registrationsControllerPatchRegistrationsStatus(programId: number, registrationStatusPatchDto: RegistrationStatusPatchDto, page?: boolean, limit?: boolean, dryRun?: boolean, filterReferenceId?: Array<string>, filterStatus?: Array<string>, filterId?: Array<string>, filterRegistrationCreatedDate?: Array<string>, filterPhoneNumber?: Array<string>, filterPreferredLanguage?: Array<string>, filterInclusionScore?: Array<string>, filterPaymentAmountMultiplier?: Array<string>, filterFinancialServiceProvider?: Array<string>, filterFspDisplayName?: Array<string>, filterRegistrationProgramId?: Array<string>, filterMaxPayments?: Array<string>, filterPaymentCount?: Array<string>, filterPaymentCountRemaining?: Array<string>, filterPersonAffectedSequence?: Array<string>, filterLastMessageStatus?: Array<string>, filterFailedPayment?: Array<string>, filterWaitingPayment?: Array<string>, filterSuccessPayment?: Array<string>, filterNotYetSentPayment?: Array<string>, sortBy?: Array<number>, search?: string, searchBy?: Array<string>, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<BulkActionResultDto>>;
    public registrationsControllerPatchRegistrationsStatus(programId: number, registrationStatusPatchDto: RegistrationStatusPatchDto, page?: boolean, limit?: boolean, dryRun?: boolean, filterReferenceId?: Array<string>, filterStatus?: Array<string>, filterId?: Array<string>, filterRegistrationCreatedDate?: Array<string>, filterPhoneNumber?: Array<string>, filterPreferredLanguage?: Array<string>, filterInclusionScore?: Array<string>, filterPaymentAmountMultiplier?: Array<string>, filterFinancialServiceProvider?: Array<string>, filterFspDisplayName?: Array<string>, filterRegistrationProgramId?: Array<string>, filterMaxPayments?: Array<string>, filterPaymentCount?: Array<string>, filterPaymentCountRemaining?: Array<string>, filterPersonAffectedSequence?: Array<string>, filterLastMessageStatus?: Array<string>, filterFailedPayment?: Array<string>, filterWaitingPayment?: Array<string>, filterSuccessPayment?: Array<string>, filterNotYetSentPayment?: Array<string>, sortBy?: Array<number>, search?: string, searchBy?: Array<string>, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<BulkActionResultDto>>;
    public registrationsControllerPatchRegistrationsStatus(programId: number, registrationStatusPatchDto: RegistrationStatusPatchDto, page?: boolean, limit?: boolean, dryRun?: boolean, filterReferenceId?: Array<string>, filterStatus?: Array<string>, filterId?: Array<string>, filterRegistrationCreatedDate?: Array<string>, filterPhoneNumber?: Array<string>, filterPreferredLanguage?: Array<string>, filterInclusionScore?: Array<string>, filterPaymentAmountMultiplier?: Array<string>, filterFinancialServiceProvider?: Array<string>, filterFspDisplayName?: Array<string>, filterRegistrationProgramId?: Array<string>, filterMaxPayments?: Array<string>, filterPaymentCount?: Array<string>, filterPaymentCountRemaining?: Array<string>, filterPersonAffectedSequence?: Array<string>, filterLastMessageStatus?: Array<string>, filterFailedPayment?: Array<string>, filterWaitingPayment?: Array<string>, filterSuccessPayment?: Array<string>, filterNotYetSentPayment?: Array<string>, sortBy?: Array<number>, search?: string, searchBy?: Array<string>, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {
        if (programId === null || programId === undefined) {
            throw new Error('Required parameter programId was null or undefined when calling registrationsControllerPatchRegistrationsStatus.');
        }
        if (registrationStatusPatchDto === null || registrationStatusPatchDto === undefined) {
            throw new Error('Required parameter registrationStatusPatchDto was null or undefined when calling registrationsControllerPatchRegistrationsStatus.');
        }

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (page !== undefined && page !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>page, 'page');
        }
        if (limit !== undefined && limit !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>limit, 'limit');
        }
        if (dryRun !== undefined && dryRun !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>dryRun, 'dryRun');
        }
        if (filterReferenceId) {
            filterReferenceId.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'filter.referenceId');
            })
        }
        if (filterStatus) {
            filterStatus.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'filter.status');
            })
        }
        if (filterId) {
            filterId.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'filter.id');
            })
        }
        if (filterRegistrationCreatedDate) {
            filterRegistrationCreatedDate.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'filter.registrationCreatedDate');
            })
        }
        if (filterPhoneNumber) {
            filterPhoneNumber.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'filter.phoneNumber');
            })
        }
        if (filterPreferredLanguage) {
            filterPreferredLanguage.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'filter.preferredLanguage');
            })
        }
        if (filterInclusionScore) {
            filterInclusionScore.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'filter.inclusionScore');
            })
        }
        if (filterPaymentAmountMultiplier) {
            filterPaymentAmountMultiplier.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'filter.paymentAmountMultiplier');
            })
        }
        if (filterFinancialServiceProvider) {
            filterFinancialServiceProvider.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'filter.financialServiceProvider');
            })
        }
        if (filterFspDisplayName) {
            filterFspDisplayName.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'filter.fspDisplayName');
            })
        }
        if (filterRegistrationProgramId) {
            filterRegistrationProgramId.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'filter.registrationProgramId');
            })
        }
        if (filterMaxPayments) {
            filterMaxPayments.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'filter.maxPayments');
            })
        }
        if (filterPaymentCount) {
            filterPaymentCount.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'filter.paymentCount');
            })
        }
        if (filterPaymentCountRemaining) {
            filterPaymentCountRemaining.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'filter.paymentCountRemaining');
            })
        }
        if (filterPersonAffectedSequence) {
            filterPersonAffectedSequence.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'filter.personAffectedSequence');
            })
        }
        if (filterLastMessageStatus) {
            filterLastMessageStatus.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'filter.lastMessageStatus');
            })
        }
        if (filterFailedPayment) {
            filterFailedPayment.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'filter.failedPayment');
            })
        }
        if (filterWaitingPayment) {
            filterWaitingPayment.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'filter.waitingPayment');
            })
        }
        if (filterSuccessPayment) {
            filterSuccessPayment.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'filter.successPayment');
            })
        }
        if (filterNotYetSentPayment) {
            filterNotYetSentPayment.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'filter.notYetSentPayment');
            })
        }
        if (sortBy) {
            sortBy.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'sortBy');
            })
        }
        if (search !== undefined && search !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>search, 'search');
        }
        if (searchBy) {
            searchBy.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'searchBy');
            })
        }

        let localVarHeaders = this.defaultHeaders;

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }

        let localVarTransferCache: boolean | undefined = options && options.transferCache;
        if (localVarTransferCache === undefined) {
            localVarTransferCache = true;
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
        }

        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/api/programs/${this.configuration.encodeParam({name: "programId", value: programId, in: "path", style: "simple", explode: false, dataType: "number", dataFormat: undefined})}/registrations/status`;
        return this.httpClient.request<BulkActionResultDto>('patch', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                body: registrationStatusPatchDto,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                transferCache: localVarTransferCache,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * [SCOPED] Sends custom message via sms or whatsapp to set of PAs that can be defined via filter parameters.
     * @param programId 
     * @param sendCustomTextDto 
     * @param page Not used for this endpoint
     * @param limit Not used for this endpoint
     * @param dryRun        Only when set explicitly to \&quot;true\&quot;, this will simulate (and NOT actually DO) the action.       Instead it will return how many PA this action can be applied to.       No messages will be sent.       
     * @param filterReferenceId Filter by referenceId query param.           &lt;p&gt;              &lt;b&gt;Format: &lt;/b&gt; filter.referenceId&#x3D;{$not}:OPERATION:VALUE           &lt;/p&gt;           &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; filter.referenceId&#x3D;$not:$like:John Doe&amp;filter.referenceId&#x3D;like:John           &lt;/p&gt;           &lt;h4&gt;Available Operations&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;$eq&lt;/li&gt; &lt;li&gt;$in&lt;/li&gt; &lt;li&gt;$ilike&lt;/li&gt; &lt;li&gt;$null&lt;/li&gt;&lt;/ul&gt;
     * @param filterStatus Filter by status query param.           &lt;p&gt;              &lt;b&gt;Format: &lt;/b&gt; filter.status&#x3D;{$not}:OPERATION:VALUE           &lt;/p&gt;           &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; filter.status&#x3D;$not:$like:John Doe&amp;filter.status&#x3D;like:John           &lt;/p&gt;           &lt;h4&gt;Available Operations&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;$eq&lt;/li&gt; &lt;li&gt;$in&lt;/li&gt; &lt;li&gt;$ilike&lt;/li&gt; &lt;li&gt;$null&lt;/li&gt;&lt;/ul&gt;
     * @param filterId Filter by id query param.           &lt;p&gt;              &lt;b&gt;Format: &lt;/b&gt; filter.id&#x3D;{$not}:OPERATION:VALUE           &lt;/p&gt;           &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; filter.id&#x3D;$not:$like:John Doe&amp;filter.id&#x3D;like:John           &lt;/p&gt;           &lt;h4&gt;Available Operations&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;$eq&lt;/li&gt; &lt;li&gt;$null&lt;/li&gt;&lt;/ul&gt;
     * @param filterRegistrationCreatedDate Filter by registrationCreatedDate query param.           &lt;p&gt;              &lt;b&gt;Format: &lt;/b&gt; filter.registrationCreatedDate&#x3D;{$not}:OPERATION:VALUE           &lt;/p&gt;           &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; filter.registrationCreatedDate&#x3D;$not:$like:John Doe&amp;filter.registrationCreatedDate&#x3D;like:John           &lt;/p&gt;           &lt;h4&gt;Available Operations&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;$eq&lt;/li&gt; &lt;li&gt;$in&lt;/li&gt; &lt;li&gt;$ilike&lt;/li&gt; &lt;li&gt;$null&lt;/li&gt;&lt;/ul&gt;
     * @param filterPhoneNumber Filter by phoneNumber query param.           &lt;p&gt;              &lt;b&gt;Format: &lt;/b&gt; filter.phoneNumber&#x3D;{$not}:OPERATION:VALUE           &lt;/p&gt;           &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; filter.phoneNumber&#x3D;$not:$like:John Doe&amp;filter.phoneNumber&#x3D;like:John           &lt;/p&gt;           &lt;h4&gt;Available Operations&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;$eq&lt;/li&gt; &lt;li&gt;$in&lt;/li&gt; &lt;li&gt;$ilike&lt;/li&gt; &lt;li&gt;$null&lt;/li&gt;&lt;/ul&gt;
     * @param filterPreferredLanguage Filter by preferredLanguage query param.           &lt;p&gt;              &lt;b&gt;Format: &lt;/b&gt; filter.preferredLanguage&#x3D;{$not}:OPERATION:VALUE           &lt;/p&gt;           &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; filter.preferredLanguage&#x3D;$not:$like:John Doe&amp;filter.preferredLanguage&#x3D;like:John           &lt;/p&gt;           &lt;h4&gt;Available Operations&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;$eq&lt;/li&gt; &lt;li&gt;$in&lt;/li&gt; &lt;li&gt;$ilike&lt;/li&gt; &lt;li&gt;$null&lt;/li&gt;&lt;/ul&gt;
     * @param filterInclusionScore Filter by inclusionScore query param.           &lt;p&gt;              &lt;b&gt;Format: &lt;/b&gt; filter.inclusionScore&#x3D;{$not}:OPERATION:VALUE           &lt;/p&gt;           &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; filter.inclusionScore&#x3D;$not:$like:John Doe&amp;filter.inclusionScore&#x3D;like:John           &lt;/p&gt;           &lt;h4&gt;Available Operations&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;$eq&lt;/li&gt; &lt;li&gt;$null&lt;/li&gt;&lt;/ul&gt;
     * @param filterPaymentAmountMultiplier Filter by paymentAmountMultiplier query param.           &lt;p&gt;              &lt;b&gt;Format: &lt;/b&gt; filter.paymentAmountMultiplier&#x3D;{$not}:OPERATION:VALUE           &lt;/p&gt;           &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; filter.paymentAmountMultiplier&#x3D;$not:$like:John Doe&amp;filter.paymentAmountMultiplier&#x3D;like:John           &lt;/p&gt;           &lt;h4&gt;Available Operations&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;$eq&lt;/li&gt; &lt;li&gt;$null&lt;/li&gt;&lt;/ul&gt;
     * @param filterFinancialServiceProvider Filter by financialServiceProvider query param.           &lt;p&gt;              &lt;b&gt;Format: &lt;/b&gt; filter.financialServiceProvider&#x3D;{$not}:OPERATION:VALUE           &lt;/p&gt;           &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; filter.financialServiceProvider&#x3D;$not:$like:John Doe&amp;filter.financialServiceProvider&#x3D;like:John           &lt;/p&gt;           &lt;h4&gt;Available Operations&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;$eq&lt;/li&gt; &lt;li&gt;$in&lt;/li&gt; &lt;li&gt;$ilike&lt;/li&gt; &lt;li&gt;$null&lt;/li&gt;&lt;/ul&gt;
     * @param filterFspDisplayName Filter by fspDisplayName query param.           &lt;p&gt;              &lt;b&gt;Format: &lt;/b&gt; filter.fspDisplayName&#x3D;{$not}:OPERATION:VALUE           &lt;/p&gt;           &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; filter.fspDisplayName&#x3D;$not:$like:John Doe&amp;filter.fspDisplayName&#x3D;like:John           &lt;/p&gt;           &lt;h4&gt;Available Operations&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;$eq&lt;/li&gt; &lt;li&gt;$in&lt;/li&gt; &lt;li&gt;$ilike&lt;/li&gt; &lt;li&gt;$null&lt;/li&gt;&lt;/ul&gt;
     * @param filterRegistrationProgramId Filter by registrationProgramId query param.           &lt;p&gt;              &lt;b&gt;Format: &lt;/b&gt; filter.registrationProgramId&#x3D;{$not}:OPERATION:VALUE           &lt;/p&gt;           &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; filter.registrationProgramId&#x3D;$not:$like:John Doe&amp;filter.registrationProgramId&#x3D;like:John           &lt;/p&gt;           &lt;h4&gt;Available Operations&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;$eq&lt;/li&gt; &lt;li&gt;$null&lt;/li&gt;&lt;/ul&gt;
     * @param filterMaxPayments Filter by maxPayments query param.           &lt;p&gt;              &lt;b&gt;Format: &lt;/b&gt; filter.maxPayments&#x3D;{$not}:OPERATION:VALUE           &lt;/p&gt;           &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; filter.maxPayments&#x3D;$not:$like:John Doe&amp;filter.maxPayments&#x3D;like:John           &lt;/p&gt;           &lt;h4&gt;Available Operations&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;$eq&lt;/li&gt; &lt;li&gt;$null&lt;/li&gt;&lt;/ul&gt;
     * @param filterPaymentCount Filter by paymentCount query param.           &lt;p&gt;              &lt;b&gt;Format: &lt;/b&gt; filter.paymentCount&#x3D;{$not}:OPERATION:VALUE           &lt;/p&gt;           &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; filter.paymentCount&#x3D;$not:$like:John Doe&amp;filter.paymentCount&#x3D;like:John           &lt;/p&gt;           &lt;h4&gt;Available Operations&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;$eq&lt;/li&gt; &lt;li&gt;$null&lt;/li&gt;&lt;/ul&gt;
     * @param filterPaymentCountRemaining Filter by paymentCountRemaining query param.           &lt;p&gt;              &lt;b&gt;Format: &lt;/b&gt; filter.paymentCountRemaining&#x3D;{$not}:OPERATION:VALUE           &lt;/p&gt;           &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; filter.paymentCountRemaining&#x3D;$not:$like:John Doe&amp;filter.paymentCountRemaining&#x3D;like:John           &lt;/p&gt;           &lt;h4&gt;Available Operations&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;$eq&lt;/li&gt; &lt;li&gt;$null&lt;/li&gt;&lt;/ul&gt;
     * @param filterPersonAffectedSequence Filter by personAffectedSequence query param.           &lt;p&gt;              &lt;b&gt;Format: &lt;/b&gt; filter.personAffectedSequence&#x3D;{$not}:OPERATION:VALUE           &lt;/p&gt;           &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; filter.personAffectedSequence&#x3D;$not:$like:John Doe&amp;filter.personAffectedSequence&#x3D;like:John           &lt;/p&gt;           &lt;h4&gt;Available Operations&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;$eq&lt;/li&gt; &lt;li&gt;$in&lt;/li&gt; &lt;li&gt;$ilike&lt;/li&gt; &lt;li&gt;$null&lt;/li&gt;&lt;/ul&gt;
     * @param filterLastMessageStatus Filter by lastMessageStatus query param.           &lt;p&gt;              &lt;b&gt;Format: &lt;/b&gt; filter.lastMessageStatus&#x3D;{$not}:OPERATION:VALUE           &lt;/p&gt;           &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; filter.lastMessageStatus&#x3D;$not:$like:John Doe&amp;filter.lastMessageStatus&#x3D;like:John           &lt;/p&gt;           &lt;h4&gt;Available Operations&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;$eq&lt;/li&gt; &lt;li&gt;$in&lt;/li&gt; &lt;li&gt;$ilike&lt;/li&gt; &lt;li&gt;$null&lt;/li&gt;&lt;/ul&gt;
     * @param filterFailedPayment Filter by failedPayment query param.           &lt;p&gt;              &lt;b&gt;Format: &lt;/b&gt; filter.failedPayment&#x3D;{$not}:OPERATION:VALUE           &lt;/p&gt;           &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; filter.failedPayment&#x3D;$not:$like:John Doe&amp;filter.failedPayment&#x3D;like:John           &lt;/p&gt;           &lt;h4&gt;Available Operations&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;$eq&lt;/li&gt; &lt;li&gt;$null&lt;/li&gt;&lt;/ul&gt;
     * @param filterWaitingPayment Filter by waitingPayment query param.           &lt;p&gt;              &lt;b&gt;Format: &lt;/b&gt; filter.waitingPayment&#x3D;{$not}:OPERATION:VALUE           &lt;/p&gt;           &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; filter.waitingPayment&#x3D;$not:$like:John Doe&amp;filter.waitingPayment&#x3D;like:John           &lt;/p&gt;           &lt;h4&gt;Available Operations&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;$eq&lt;/li&gt; &lt;li&gt;$null&lt;/li&gt;&lt;/ul&gt;
     * @param filterSuccessPayment Filter by successPayment query param.           &lt;p&gt;              &lt;b&gt;Format: &lt;/b&gt; filter.successPayment&#x3D;{$not}:OPERATION:VALUE           &lt;/p&gt;           &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; filter.successPayment&#x3D;$not:$like:John Doe&amp;filter.successPayment&#x3D;like:John           &lt;/p&gt;           &lt;h4&gt;Available Operations&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;$eq&lt;/li&gt; &lt;li&gt;$null&lt;/li&gt;&lt;/ul&gt;
     * @param filterNotYetSentPayment Filter by notYetSentPayment query param.           &lt;p&gt;              &lt;b&gt;Format: &lt;/b&gt; filter.notYetSentPayment&#x3D;{$not}:OPERATION:VALUE           &lt;/p&gt;           &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; filter.notYetSentPayment&#x3D;$not:$like:John Doe&amp;filter.notYetSentPayment&#x3D;like:John           &lt;/p&gt;           &lt;h4&gt;Available Operations&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;$eq&lt;/li&gt; &lt;li&gt;$null&lt;/li&gt;&lt;/ul&gt;
     * @param sortBy Parameter to sort by.       &lt;p&gt;To sort by multiple fields, just provide query param multiple types. The order in url defines an order of sorting&lt;/p&gt;       &lt;p&gt;              &lt;b&gt;Format: &lt;/b&gt; fieldName:DIRECTION           &lt;/p&gt;       &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; sortBy&#x3D;id:DESC&amp;sortBy&#x3D;createdAt:ASC           &lt;/p&gt;       &lt;p&gt;              &lt;b&gt;Default Value: &lt;/b&gt; No default sorting specified, the result order is not guaranteed           &lt;/p&gt;       &lt;h4&gt;Available Fields&lt;/h4&gt;&lt;ul&gt;&lt;/ul&gt;       
     * @param search Search term to filter result values         &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; John           &lt;/p&gt;         &lt;p&gt;              &lt;b&gt;Default Value: &lt;/b&gt; No default value           &lt;/p&gt;         
     * @param searchBy List of fields to search by term to filter result values         &lt;p&gt;              &lt;b&gt;Example: &lt;/b&gt; data.(value)           &lt;/p&gt;         &lt;p&gt;              &lt;b&gt;Default Value: &lt;/b&gt; By default all fields mentioned below will be used to search by term           &lt;/p&gt;         &lt;h4&gt;Available Fields&lt;/h4&gt;&lt;ul&gt;&lt;li&gt;data.(value)&lt;/li&gt;&lt;/ul&gt;         
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public registrationsControllerSendCustomTextMessage(programId: number, sendCustomTextDto: SendCustomTextDto, page?: boolean, limit?: boolean, dryRun?: boolean, filterReferenceId?: Array<string>, filterStatus?: Array<string>, filterId?: Array<string>, filterRegistrationCreatedDate?: Array<string>, filterPhoneNumber?: Array<string>, filterPreferredLanguage?: Array<string>, filterInclusionScore?: Array<string>, filterPaymentAmountMultiplier?: Array<string>, filterFinancialServiceProvider?: Array<string>, filterFspDisplayName?: Array<string>, filterRegistrationProgramId?: Array<string>, filterMaxPayments?: Array<string>, filterPaymentCount?: Array<string>, filterPaymentCountRemaining?: Array<string>, filterPersonAffectedSequence?: Array<string>, filterLastMessageStatus?: Array<string>, filterFailedPayment?: Array<string>, filterWaitingPayment?: Array<string>, filterSuccessPayment?: Array<string>, filterNotYetSentPayment?: Array<string>, sortBy?: Array<number>, search?: string, searchBy?: Array<string>, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<BulkActionResultDto>;
    public registrationsControllerSendCustomTextMessage(programId: number, sendCustomTextDto: SendCustomTextDto, page?: boolean, limit?: boolean, dryRun?: boolean, filterReferenceId?: Array<string>, filterStatus?: Array<string>, filterId?: Array<string>, filterRegistrationCreatedDate?: Array<string>, filterPhoneNumber?: Array<string>, filterPreferredLanguage?: Array<string>, filterInclusionScore?: Array<string>, filterPaymentAmountMultiplier?: Array<string>, filterFinancialServiceProvider?: Array<string>, filterFspDisplayName?: Array<string>, filterRegistrationProgramId?: Array<string>, filterMaxPayments?: Array<string>, filterPaymentCount?: Array<string>, filterPaymentCountRemaining?: Array<string>, filterPersonAffectedSequence?: Array<string>, filterLastMessageStatus?: Array<string>, filterFailedPayment?: Array<string>, filterWaitingPayment?: Array<string>, filterSuccessPayment?: Array<string>, filterNotYetSentPayment?: Array<string>, sortBy?: Array<number>, search?: string, searchBy?: Array<string>, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<BulkActionResultDto>>;
    public registrationsControllerSendCustomTextMessage(programId: number, sendCustomTextDto: SendCustomTextDto, page?: boolean, limit?: boolean, dryRun?: boolean, filterReferenceId?: Array<string>, filterStatus?: Array<string>, filterId?: Array<string>, filterRegistrationCreatedDate?: Array<string>, filterPhoneNumber?: Array<string>, filterPreferredLanguage?: Array<string>, filterInclusionScore?: Array<string>, filterPaymentAmountMultiplier?: Array<string>, filterFinancialServiceProvider?: Array<string>, filterFspDisplayName?: Array<string>, filterRegistrationProgramId?: Array<string>, filterMaxPayments?: Array<string>, filterPaymentCount?: Array<string>, filterPaymentCountRemaining?: Array<string>, filterPersonAffectedSequence?: Array<string>, filterLastMessageStatus?: Array<string>, filterFailedPayment?: Array<string>, filterWaitingPayment?: Array<string>, filterSuccessPayment?: Array<string>, filterNotYetSentPayment?: Array<string>, sortBy?: Array<number>, search?: string, searchBy?: Array<string>, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<BulkActionResultDto>>;
    public registrationsControllerSendCustomTextMessage(programId: number, sendCustomTextDto: SendCustomTextDto, page?: boolean, limit?: boolean, dryRun?: boolean, filterReferenceId?: Array<string>, filterStatus?: Array<string>, filterId?: Array<string>, filterRegistrationCreatedDate?: Array<string>, filterPhoneNumber?: Array<string>, filterPreferredLanguage?: Array<string>, filterInclusionScore?: Array<string>, filterPaymentAmountMultiplier?: Array<string>, filterFinancialServiceProvider?: Array<string>, filterFspDisplayName?: Array<string>, filterRegistrationProgramId?: Array<string>, filterMaxPayments?: Array<string>, filterPaymentCount?: Array<string>, filterPaymentCountRemaining?: Array<string>, filterPersonAffectedSequence?: Array<string>, filterLastMessageStatus?: Array<string>, filterFailedPayment?: Array<string>, filterWaitingPayment?: Array<string>, filterSuccessPayment?: Array<string>, filterNotYetSentPayment?: Array<string>, sortBy?: Array<number>, search?: string, searchBy?: Array<string>, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: 'application/json', context?: HttpContext, transferCache?: boolean}): Observable<any> {
        if (programId === null || programId === undefined) {
            throw new Error('Required parameter programId was null or undefined when calling registrationsControllerSendCustomTextMessage.');
        }
        if (sendCustomTextDto === null || sendCustomTextDto === undefined) {
            throw new Error('Required parameter sendCustomTextDto was null or undefined when calling registrationsControllerSendCustomTextMessage.');
        }

        let localVarQueryParameters = new HttpParams({encoder: this.encoder});
        if (page !== undefined && page !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>page, 'page');
        }
        if (limit !== undefined && limit !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>limit, 'limit');
        }
        if (dryRun !== undefined && dryRun !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>dryRun, 'dryRun');
        }
        if (filterReferenceId) {
            filterReferenceId.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'filter.referenceId');
            })
        }
        if (filterStatus) {
            filterStatus.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'filter.status');
            })
        }
        if (filterId) {
            filterId.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'filter.id');
            })
        }
        if (filterRegistrationCreatedDate) {
            filterRegistrationCreatedDate.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'filter.registrationCreatedDate');
            })
        }
        if (filterPhoneNumber) {
            filterPhoneNumber.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'filter.phoneNumber');
            })
        }
        if (filterPreferredLanguage) {
            filterPreferredLanguage.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'filter.preferredLanguage');
            })
        }
        if (filterInclusionScore) {
            filterInclusionScore.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'filter.inclusionScore');
            })
        }
        if (filterPaymentAmountMultiplier) {
            filterPaymentAmountMultiplier.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'filter.paymentAmountMultiplier');
            })
        }
        if (filterFinancialServiceProvider) {
            filterFinancialServiceProvider.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'filter.financialServiceProvider');
            })
        }
        if (filterFspDisplayName) {
            filterFspDisplayName.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'filter.fspDisplayName');
            })
        }
        if (filterRegistrationProgramId) {
            filterRegistrationProgramId.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'filter.registrationProgramId');
            })
        }
        if (filterMaxPayments) {
            filterMaxPayments.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'filter.maxPayments');
            })
        }
        if (filterPaymentCount) {
            filterPaymentCount.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'filter.paymentCount');
            })
        }
        if (filterPaymentCountRemaining) {
            filterPaymentCountRemaining.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'filter.paymentCountRemaining');
            })
        }
        if (filterPersonAffectedSequence) {
            filterPersonAffectedSequence.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'filter.personAffectedSequence');
            })
        }
        if (filterLastMessageStatus) {
            filterLastMessageStatus.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'filter.lastMessageStatus');
            })
        }
        if (filterFailedPayment) {
            filterFailedPayment.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'filter.failedPayment');
            })
        }
        if (filterWaitingPayment) {
            filterWaitingPayment.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'filter.waitingPayment');
            })
        }
        if (filterSuccessPayment) {
            filterSuccessPayment.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'filter.successPayment');
            })
        }
        if (filterNotYetSentPayment) {
            filterNotYetSentPayment.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'filter.notYetSentPayment');
            })
        }
        if (sortBy) {
            sortBy.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'sortBy');
            })
        }
        if (search !== undefined && search !== null) {
          localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
            <any>search, 'search');
        }
        if (searchBy) {
            searchBy.forEach((element) => {
                localVarQueryParameters = this.addToHttpParams(localVarQueryParameters,
                  <any>element, 'searchBy');
            })
        }

        let localVarHeaders = this.defaultHeaders;

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
                'application/json'
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }

        let localVarTransferCache: boolean | undefined = options && options.transferCache;
        if (localVarTransferCache === undefined) {
            localVarTransferCache = true;
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
        }

        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/api/programs/${this.configuration.encodeParam({name: "programId", value: programId, in: "path", style: "simple", explode: false, dataType: "number", dataFormat: undefined})}/registrations/message`;
        return this.httpClient.request<BulkActionResultDto>('post', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                body: sendCustomTextDto,
                params: localVarQueryParameters,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                transferCache: localVarTransferCache,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * [SCOPED] [EXTERNALLY USED] Update chosen FSP and attributes. This will delete any custom data field related to the old FSP!
     * @param programId 
     * @param referenceId 
     * @param updateChosenFspDto 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public registrationsControllerUpdateChosenFsp(programId: number, referenceId: string, updateChosenFspDto: UpdateChosenFspDto, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined, context?: HttpContext, transferCache?: boolean}): Observable<any>;
    public registrationsControllerUpdateChosenFsp(programId: number, referenceId: string, updateChosenFspDto: UpdateChosenFspDto, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined, context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<any>>;
    public registrationsControllerUpdateChosenFsp(programId: number, referenceId: string, updateChosenFspDto: UpdateChosenFspDto, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined, context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<any>>;
    public registrationsControllerUpdateChosenFsp(programId: number, referenceId: string, updateChosenFspDto: UpdateChosenFspDto, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: undefined, context?: HttpContext, transferCache?: boolean}): Observable<any> {
        if (programId === null || programId === undefined) {
            throw new Error('Required parameter programId was null or undefined when calling registrationsControllerUpdateChosenFsp.');
        }
        if (referenceId === null || referenceId === undefined) {
            throw new Error('Required parameter referenceId was null or undefined when calling registrationsControllerUpdateChosenFsp.');
        }
        if (updateChosenFspDto === null || updateChosenFspDto === undefined) {
            throw new Error('Required parameter updateChosenFspDto was null or undefined when calling registrationsControllerUpdateChosenFsp.');
        }

        let localVarHeaders = this.defaultHeaders;

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }

        let localVarTransferCache: boolean | undefined = options && options.transferCache;
        if (localVarTransferCache === undefined) {
            localVarTransferCache = true;
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
        }

        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/api/programs/${this.configuration.encodeParam({name: "programId", value: programId, in: "path", style: "simple", explode: false, dataType: "number", dataFormat: undefined})}/registrations/${this.configuration.encodeParam({name: "referenceId", value: referenceId, in: "path", style: "simple", explode: false, dataType: "string", dataFormat: undefined})}/fsp`;
        return this.httpClient.request<any>('put', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                body: updateChosenFspDto,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                transferCache: localVarTransferCache,
                reportProgress: reportProgress
            }
        );
    }

    /**
     * [SCOPED] [EXTERNALLY USED] Update provided attributes of registration (Used by Aidworker)
     * @param programId 
     * @param referenceId 
     * @param updateRegistrationDto 
     * @param observe set whether or not to return the data Observable as the body, response or events. defaults to returning the body.
     * @param reportProgress flag to report request and response progress.
     */
    public registrationsControllerUpdateRegistration(programId: number, referenceId: string, updateRegistrationDto: UpdateRegistrationDto, observe?: 'body', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined, context?: HttpContext, transferCache?: boolean}): Observable<any>;
    public registrationsControllerUpdateRegistration(programId: number, referenceId: string, updateRegistrationDto: UpdateRegistrationDto, observe?: 'response', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined, context?: HttpContext, transferCache?: boolean}): Observable<HttpResponse<any>>;
    public registrationsControllerUpdateRegistration(programId: number, referenceId: string, updateRegistrationDto: UpdateRegistrationDto, observe?: 'events', reportProgress?: boolean, options?: {httpHeaderAccept?: undefined, context?: HttpContext, transferCache?: boolean}): Observable<HttpEvent<any>>;
    public registrationsControllerUpdateRegistration(programId: number, referenceId: string, updateRegistrationDto: UpdateRegistrationDto, observe: any = 'body', reportProgress: boolean = false, options?: {httpHeaderAccept?: undefined, context?: HttpContext, transferCache?: boolean}): Observable<any> {
        if (programId === null || programId === undefined) {
            throw new Error('Required parameter programId was null or undefined when calling registrationsControllerUpdateRegistration.');
        }
        if (referenceId === null || referenceId === undefined) {
            throw new Error('Required parameter referenceId was null or undefined when calling registrationsControllerUpdateRegistration.');
        }
        if (updateRegistrationDto === null || updateRegistrationDto === undefined) {
            throw new Error('Required parameter updateRegistrationDto was null or undefined when calling registrationsControllerUpdateRegistration.');
        }

        let localVarHeaders = this.defaultHeaders;

        let localVarHttpHeaderAcceptSelected: string | undefined = options && options.httpHeaderAccept;
        if (localVarHttpHeaderAcceptSelected === undefined) {
            // to determine the Accept header
            const httpHeaderAccepts: string[] = [
            ];
            localVarHttpHeaderAcceptSelected = this.configuration.selectHeaderAccept(httpHeaderAccepts);
        }
        if (localVarHttpHeaderAcceptSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Accept', localVarHttpHeaderAcceptSelected);
        }

        let localVarHttpContext: HttpContext | undefined = options && options.context;
        if (localVarHttpContext === undefined) {
            localVarHttpContext = new HttpContext();
        }

        let localVarTransferCache: boolean | undefined = options && options.transferCache;
        if (localVarTransferCache === undefined) {
            localVarTransferCache = true;
        }


        // to determine the Content-Type header
        const consumes: string[] = [
            'application/json'
        ];
        const httpContentTypeSelected: string | undefined = this.configuration.selectHeaderContentType(consumes);
        if (httpContentTypeSelected !== undefined) {
            localVarHeaders = localVarHeaders.set('Content-Type', httpContentTypeSelected);
        }

        let responseType_: 'text' | 'json' | 'blob' = 'json';
        if (localVarHttpHeaderAcceptSelected) {
            if (localVarHttpHeaderAcceptSelected.startsWith('text')) {
                responseType_ = 'text';
            } else if (this.configuration.isJsonMime(localVarHttpHeaderAcceptSelected)) {
                responseType_ = 'json';
            } else {
                responseType_ = 'blob';
            }
        }

        let localVarPath = `/api/programs/${this.configuration.encodeParam({name: "programId", value: programId, in: "path", style: "simple", explode: false, dataType: "number", dataFormat: undefined})}/registrations/${this.configuration.encodeParam({name: "referenceId", value: referenceId, in: "path", style: "simple", explode: false, dataType: "string", dataFormat: undefined})}`;
        return this.httpClient.request<any>('patch', `${this.configuration.basePath}${localVarPath}`,
            {
                context: localVarHttpContext,
                body: updateRegistrationDto,
                responseType: <any>responseType_,
                withCredentials: this.configuration.withCredentials,
                headers: localVarHeaders,
                observe: observe,
                transferCache: localVarTransferCache,
                reportProgress: reportProgress
            }
        );
    }

}
