"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.ReportGenerator = void 0;
class ReportGenerator {
    /**
     * Generate a markdown summary of test results
     */
    static generateMarkdownSummary(summary, includePassing = false) {
        const { totalTests, passedTests, failedTests: failedCount, skippedTests, shards } = summary;
        let markdown = '## ðŸ§ª Test Results Summary\n\n';
        // Overall stats
        const successRate = totalTests > 0 ? Math.round((passedTests / totalTests) * 100) : 0;
        const statusEmoji = failedCount === 0 ? 'âœ…' : 'âŒ';
        markdown += `${statusEmoji} **Overall**: ${passedTests}/${totalTests} tests passed (${successRate}%)\n\n`;
        if (failedCount > 0 || skippedTests > 0) {
            markdown += '### ðŸ“Š Results Breakdown\n\n';
            markdown += `- âœ… **Passed**: ${passedTests}\n`;
            if (failedCount > 0) {
                markdown += `- âŒ **Failed**: ${failedCount}\n`;
            }
            if (skippedTests > 0) {
                markdown += `- â­ï¸ **Skipped**: ${skippedTests}\n`;
            }
            markdown += '\n';
        }
        // Shard breakdown
        if (Object.keys(shards).length > 1) {
            markdown += '### ðŸ”€ Results by Shard/Job\n\n';
            markdown += '| Shard | Runner | Passed | Failed | Skipped | Status |\n';
            markdown += '|-------|--------|--------|--------|---------|--------|\n';
            for (const [shardName, shardData] of Object.entries(shards)) {
                const shardTotal = shardData.passed + shardData.failed + shardData.skipped;
                const shardSuccess = shardData.failed === 0 ? 'âœ…' : 'âŒ';
                markdown += `| ${shardName} | ${shardData.runner} | ${shardData.passed} | ${shardData.failed} | ${shardData.skipped} | ${shardSuccess} |\n`;
            }
            markdown += '\n';
        }
        // Failed tests details
        const failedTestResults = summary.results.filter(r => r.status === 'failed');
        if (failedTestResults.length > 0) {
            markdown += '### âŒ Failed Tests\n\n';
            const groupedByFile = this.groupTestsByFile(failedTestResults);
            for (const [file, tests] of Object.entries(groupedByFile)) {
                markdown += `#### ðŸ“„ \`${this.getRelativePath(file)}\`\n\n`;
                for (const test of tests) {
                    const suiteName = test.suiteName ? ` (${test.suiteName})` : '';
                    const shardInfo = test.shard ? ` [Shard: ${test.shard}]` : '';
                    const retryInfo = test.retries && test.retries > 0 ? ` [Retries: ${test.retries}]` : '';
                    markdown += `- **${test.name}**${suiteName}${shardInfo}${retryInfo}\n`;
                    if (test.error) {
                        // Truncate long error messages
                        const errorLines = test.error.split('\n');
                        const truncatedError = errorLines.slice(0, 5).join('\n');
                        const hasMore = errorLines.length > 5;
                        markdown += '  ```\n';
                        markdown += `  ${truncatedError}\n`;
                        if (hasMore) {
                            markdown += `  ... (${errorLines.length - 5} more lines)\n`;
                        }
                        markdown += '  ```\n';
                    }
                    markdown += '\n';
                }
            }
        }
        // Passed tests (if requested)
        if (includePassing && passedTests > 0) {
            const passedTestsList = summary.results.filter(r => r.status === 'passed');
            markdown += '### âœ… Passed Tests\n\n';
            const groupedByRunner = this.groupTestsByRunner(passedTestsList);
            for (const [runner, tests] of Object.entries(groupedByRunner)) {
                markdown += `#### ${runner.toUpperCase()} (${tests.length} tests)\n\n`;
                markdown += '<details>\n<summary>View passed tests</summary>\n\n';
                const groupedByFile = this.groupTestsByFile(tests);
                for (const [file, fileTests] of Object.entries(groupedByFile)) {
                    markdown += `**\`${this.getRelativePath(file)}\`**: ${fileTests.length} tests\n`;
                }
                markdown += '\n</details>\n\n';
            }
        }
        // Add metadata
        markdown += '---\n';
        markdown += `<sub>Generated by Test Aggregator â€¢ Total duration: ${this.formatDuration(summary.duration)}</sub>\n`;
        return markdown;
    }
    /**
     * Generate a compact status for GitHub checks
     */
    static generateStatusMessage(summary) {
        const { totalTests, passedTests, failedTests: failedCount } = summary;
        const successRate = totalTests > 0 ? Math.round((passedTests / totalTests) * 100) : 0;
        if (failedCount === 0) {
            return `âœ… All ${totalTests} tests passed (${successRate}%)`;
        }
        else {
            return `âŒ ${failedCount} of ${totalTests} tests failed (${successRate}% passed)`;
        }
    }
    /**
     * Group tests by file
     */
    static groupTestsByFile(tests) {
        return tests.reduce((acc, test) => {
            if (!acc[test.file]) {
                acc[test.file] = [];
            }
            acc[test.file].push(test);
            return acc;
        }, {});
    }
    /**
     * Group tests by runner
     */
    static groupTestsByRunner(tests) {
        return tests.reduce((acc, test) => {
            if (!acc[test.runner]) {
                acc[test.runner] = [];
            }
            acc[test.runner].push(test);
            return acc;
        }, {});
    }
    /**
     * Get relative path for cleaner display
     */
    static getRelativePath(filePath) {
        // Remove common prefixes to make paths more readable
        return filePath
            .replace(/^.*\/node_modules\//, 'node_modules/')
            .replace(/^.*\/services\//, 'services/')
            .replace(/^.*\/interfaces\//, 'interfaces/')
            .replace(/^.*\/e2e\//, 'e2e/')
            .replace(/^.*\/dist\//, 'dist/')
            .replace(/^.*\/src\//, 'src/');
    }
    /**
     * Format duration in a human-readable way
     */
    static formatDuration(milliseconds) {
        if (milliseconds < 1000) {
            return `${Math.round(milliseconds)}ms`;
        }
        const seconds = Math.round(milliseconds / 1000);
        if (seconds < 60) {
            return `${seconds}s`;
        }
        const minutes = Math.floor(seconds / 60);
        const remainingSeconds = seconds % 60;
        return `${minutes}m ${remainingSeconds}s`;
    }
}
exports.ReportGenerator = ReportGenerator;
//# sourceMappingURL=report.js.map